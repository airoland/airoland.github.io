{
    "title": "SaaS 分布式多租户数据库设计",
    "time": "2017/09/01 17:51:02",
    "tags": ["SaaS", "MySQL", "Hibernate"],
    "content": "[TOC]\n\n# 1. 概述\n\n其实SaaS也发展了N多年了，但一直以来都不是很火，不同的人可能对SaaS也有不同的理解。就我个人的理解，十几年前我们做IT卖产品，尤其是企业级产品时，通常都需要**到客户的现场去实施**，客户需要准备一个独立机房，软件大多是部署在客户的局域网上，而后续的更新和维护通常也需要持续跟进并到现场解决问题。在那个年代，云服务器还只是一个概念，毕竟基础设施差的太多了，性价比也完全不够。\n\n随着硬件技术的发展和性价比的提高，IaaS疯狂生长，软件开发商们发现可以把产品部署在云端，让客户以付费租赁的方式按需购买产品（变成了租户），软件开发商提供统一的更新和维护服务（公有云），或租户花更多的钱来获得独享的功能和服务（私有云），租户不需要再费力自己搭建机房，软件开发商也不需要为每个租户都安排实施专员，由此便产生了SaaS的概念。后面随着Spring Cloud等分布式微服务体系的出现，“混合云”也进入到了人们的视野。\n\n那么SaaS服务的关键就在于，以前客户是在自己的局域网里玩，数据有绝对的隔离性，功能可以随意定制。现在放到了互联网上，他变成了租户，你作为服务提供商如何向他保证他的数据是隔离的，他的功能是可以定制的？\n\n数据的隔离就意味着租户们的数据不应混合在一起，当然你可以说混合在一起后用租户ID来区分，然后让使用者感受起来是隔离的就好了（毕竟黑箱），但如此一来对指定租户的备份和恢复就变得相当困难，数据量大了以后分表分库或横向扩展的问题会暴露无遗，另外当租户需要定制化功能时，就意味着有很大可能他需要一套特殊的表，你会发现你的开发难度将呈几何级数增长。\n\n下面我们就来讨论一下SaaS模式的数据库设计有哪些方案。\n\n# 2. 方案比较\n\n目前主流的SaaS多租户数据库方案有以下三种：\n\n![image](http://airoland.github.io/data/article/20170901175128034/1.png)\n\n它们各自的特点为：\n\n- 完全隔离：可以理解为一个租户一个数据库，比如一个租户一个Oracle或MySQL实例，硬件成本过高，属于土豪玩法；\n- 独立Schema：即一个租户一个Schema，多个Schema共享一个数据库，属于成本和需求的折衷方案；\n- 完全共享：即上文概述中提到的所有数据都混合在一起。\n\n通常情况下我推荐大家使用折衷方案，即共享数据库，独立Schema，既满足了数据隔离，又降低了开发和硬件成本。\n\n## 2.1 Schema？\n\n有的人不了解Schema是什么，其实很多数据库中都有Schema的概念，或许他们严格意义上有略微差别，但从抽象层面上讲，当我们提到Schema时，我们指的都是同一个概念：\n\n![image](http://airoland.github.io/data/article/20170901175128034/2.png)\n\n## 2.2 MySQL的情况\n\nSchema通常有一些等价概念，比如在互联网公司常用的MySQL数据库里，Schema和Database就是等价的：\n\n![image](http://airoland.github.io/data/article/20170901175128034/3.png)\n\n也就是说，MySQL的服务实例才等同于Oracle的数据库，而MySQL的数据库（Database）其实是一个比较小的概念，这一点希望大家注意。\n\n## 2.3 优缺点\n\n![image](http://airoland.github.io/data/article/20170901175128034/4.png)\n\n下面我们边设计架构边解决已知的缺陷。\n\n# 3. 数据库架构设计\n\n## 3.1 分布式多租户\n\n**第一个问题：假设有10万个租户怎么办？**\n\n首先，10万个Schema肯定不能放在同一台机器上，既然我们采取了独立Schema的方式，那么横向扩展的优势就立即显现出来了：\n\n![image](http://airoland.github.io/data/article/20170901175128034/5.png)\n\n注意，每个节点下面其实是一个数据库集群，每个集群都可以使用`PXC`或`Master-Slave`等方案来维护同一套数据，保证数据库的高可用。对于这样的一个数据库集群，我们可以称之为一个数据源，即我不管这个数据源的集群下有多少台机器，但这个数据源的数据肯定是一致的。所有这些数据源综合起来，就是**SaaS分布式多租户数据库集群**。\n\n## 3.2 如何定位租户？\n\n当我们采用分布式存储之后，如何来定位租户呢？举个例子：\n\n![image](http://airoland.github.io/data/article/20170901175128034/6.png)\n\n即我们可以通过映射表或算法的方式，来找到租户对应的数据源和数据源下的Schema。具体怎么切换见下文第4章。\n\n## 3.3 独立的数据服务\n\n**第二个问题：如何进行批量操作（更新维护Schema、统计分析等）？**\n\n当租户较少的时候，我们可以通过搭建独立的数据服务来完成这些功能：\n\n![image](http://airoland.github.io/data/article/20170901175128034/7.png)\n\n具体来说：\n\n- 新增租户：可以执行指定的SQL脚本文件来动态创建Schema；\n- 更新维护：可以为指定的Schema集合或全部Schema执行某条SQL语句或脚本文件（刷库），来更新维护表结构或数据；\n- 统计分析：如果是为租户提供他自身数据的统计分析，那么很简单只操作它自己的Schema就够了。如果是为租户或服务商提供全局统计分析，那就需要异步聚合所有Schema的数据。\n\n但问题来了，当租户达到10万或更多级别的时候，上面的做法肯定会带来性能和等待的问题，还有没有更优化的方法？\n\n**1. 分区刷库**\n\n首先，我们需要把数据服务按功能拆分成粒度更细的微服务，比如批量刷库微服务，将性能的损耗分布到不同机器上。\n\n然后启动多个批量刷库微服务实例，每个实例负责不同区域的刷库，比如A负责第1-3000租户，B负责第3001-6000等等，这样并发刷库就可以节省总体更新维护的时间了。\n\n**2. 统计分析**\n\n这个基本属于发挥人民群众智慧的时候了，基本没有最优的方案，你可以先分区聚合统计分析一波，然后再把分区结果整体聚合统计分析出最终结果。也可以把数据通过Sqoop导出，然后用Spark或Storm来分析。\n\n通常情况下，租户都只关注他自身数据的统计分析，所以对于这类需求，基本是可以做到实时的。而一般关注全局数据的都是SaaS服务提供商，对于时效性的要求其实是可以降低的。\n\n# 4. 具体实现\n\n对于切换数据源和切换Schema的实现有多种方式，比如经典的**二级域名泛解析**————每个租户有独立的二级域名，后端通过访问的域名来识别租户。\n\n在这里我将介绍另外一种方案，它基于Hibernate在4.0加入的`Multi-tenancy`模式，并进行了一定的拓展。或许现在用Mybatis人占多数，但如果你在用更方便的Spring Data JPA，那么它是基于Hibernate的上层封装，你可以直接使用它的`Multi-tenancy`功能。\n\n## 4.1 Hibernate Multi-tenancy\n\n首先我们要配置Hibernate开启`Multi-tenancy`模式，由于Spring Boot的YAML配置尚不支持`Multi-tenancy`属性，因此我们只能使用XML或Java类来设置。\n\n假设现在我们用XML来配置Hibernate的`entityManagerFactory`，那么在`jpaProperties`我们就可以添加属性如下：\n\n```\n<prop key=\"hibernate.multiTenancy\">SCHEMA</prop>\n<prop key=\"hibernate.tenant_identifier_resolver\">com.xxx.tenant.TenantIdResolver</prop>\n<prop key=\"hibernate.multi_tenant_connection_provider\">com.xxx.tenant.SchemaBasedMultiTenantConnectionProvider</prop>\n```\n\n其中`hibernate.multiTenancy`属性表示你要使用的多租户模式，有三个值：`DATABASE`，`SCHEMA`和`DISCRIMINATOR`（5.0实现），分别对应我们在第2章提到的三种数据库方案：独立数据库、独立Schema和完全共享，在这里我们取值`SCHEMA`。\n\n`hibernate.tenant_identifier_resolver`表示指定租户身份解析器的实现类。\n\n`hibernate.multi_tenant_connection_provider`表示指定多租户连接器的实现类。\n\n## 4.2 TenantIdResolver\n\n此实现类代码如下：\n\n```\nimport org.hibernate.context.spi.CurrentTenantIdentifierResolver;\n\npublic class TenantIdResolver implements CurrentTenantIdentifierResolver {\n\t\n\t// 此方法返回当前的租户标识\n\t@Override\n\tpublic String resolveCurrentTenantIdentifier() {\n\t\treturn MultiTenant.getTenant();\n\t}\n\n\t@Override\n\tpublic boolean validateExistingCurrentSessions() {\n\t\treturn true;\n\t}\n\n}\n```\n\n`MultiTenant.getTenant()`会在第4.4节中讲解。\n\n## 4.3 SchemaBasedMultiTenantConnectionProvider\n\n这个实现类里我使用`HikariCP`作为连接池，然后通过切换连接池的方式切换数据源，本例中演示了两个数据源，大家可以自己思考如何实现更多数据源的管理。我在代码中的注释大家一定要仔细看：\n\n```\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.hibernate.HibernateException;\nimport org.hibernate.engine.jdbc.connections.spi.MultiTenantConnectionProvider;\nimport org.hibernate.hikaricp.internal.HikariCPConnectionProvider;\nimport org.hibernate.service.spi.Configurable;\nimport org.hibernate.service.spi.Stoppable;\n\npublic class SchemaBasedMultiTenantConnectionProvider implements MultiTenantConnectionProvider, Stoppable, Configurable {\n\n    private static final long serialVersionUID = 1L;\n    private final HikariCPConnectionProvider connectionProvider1 = new HikariCPConnectionProvider();\n    private final HikariCPConnectionProvider connectionProvider2 = new HikariCPConnectionProvider();\n\n    private final Map<String,HikariCPConnectionProvider> tenantIdConnMap = new HashMap<String,HikariCPConnectionProvider>();\n\n    // 动态获取数据源连接池\n    private HikariCPConnectionProvider getProvider(){\n        String tenantIdentifier = MultiTenant.getTenant();\n    \ttenantIdentifier = tenantIdentifier.split(\":\")[0];\n        return tenantIdConnMap.get(tenantIdentifier);\n    }\n\n    @Override\n    public Connection getAnyConnection() throws SQLException {\n        return getProvider().getConnection();\n    }\n\n    @Override\n    public void releaseAnyConnection(Connection connection) throws SQLException {\n        getProvider().closeConnection(connection);\n    }\n\n    @Override\n    public Connection getConnection(String tenantIdentifier) throws SQLException {\n        tenantIdentifier = tenantIdentifier.split(\":\")[1];\n        final Connection connection = getAnyConnection();\n        try {\n            // 在这里可以看到其本质就是执行了USE语句\n            connection.createStatement().execute(\"USE \" + tenantIdentifier);\n        } catch (SQLException e) {\n        \te.printStackTrace();\n            throw new HibernateException(\"Could not alter JDBC connection to specified schema [\" + tenantIdentifier\n                    + \"]\", e);\n        }\n        return connection;\n    }\n\n    @Override\n    public void releaseConnection(String tenantIdentifier, Connection connection) throws SQLException {\n        try {\n        \t// 释放连接时移到release_connection空库，防止出现异常\n        \t// 此处要特别注意，一定要USE一个已经存在的库，否则连接不会释放\n            connection.createStatement().execute(\"USE release_connection\");\n        } catch (SQLException e) {\n        \te.printStackTrace();\n            throw new HibernateException(\"Could not alter JDBC connection to specified schema [\" + tenantIdentifier\n                    + \"]\", e);\n        }\n        getProvider().closeConnection(connection);\n    }\n\n    @Override\n    public boolean isUnwrappableAs(Class unwrapType) {\n        return this.getProvider().isUnwrappableAs(unwrapType);\n    }\n\n    @Override\n    public <T> T unwrap(Class<T> unwrapType) {\n        return this.getProvider().unwrap(unwrapType);\n    }\n\n    @Override\n    public void stop() {\n        this.getProvider().stop();\n    }\n\n    @Override\n    public boolean supportsAggressiveRelease() {\n        return this.getProvider().supportsAggressiveRelease();\n    }\n\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    @Override\n    public void configure(Map configurationValues) {\n\n        // connectorProvider初始化，假设第一个数据源已在配置文件中写好\n        this.connectionProvider1.configure(configurationValues);\n\n        // 第二个数据源的配置\n        configurationValues.put(\"hibernate.connection.url\", \"jdbc:mysql://192.168.1.2:3306/test?characterEncoding=UTF-8&useSSL=false\");\n        configurationValues.put(\"hibernate.connection.username\", \"root\");\n        configurationValues.put(\"hibernate.connection.password\", \"123456\");\n        configurationValues.put(\"hibernate.hikari.dataSource.password\", \"123456\");\n        this.connectionProvider2.configure(configurationValues);\n\n        // connectorProvider与数据源的关系映射\n        tenantIdConnMap.put(\"dataSource1\", connectionProvider1);\n        tenantIdConnMap.put(\"dataSource2\", connectionProvider2);\n    }\n\n}\n```\n\n## 4.4 MultiTenant\n\n这个类提供了设置和获取租户标识的方法，以保证后续的业务处理在指定的租户上。假设我们的租户标识格式为“数据源:Schema”，那么此类实现如下：\n\n```\npublic class MultiTenant {\n\t\n\tprivate static ThreadLocal<String> MultiTenantHolder = new ThreadLocal<String>() {\n\t\t@Override\n\t\tprotected String initialValue() {\n\t\t\tString tenantId = null;\n\t\t\ttry {  \n                tenantId = \"dataSource1:test\"; \n            } catch (Exception e) {  \n                e.printStackTrace();  \n            }  \n            return tenantId;\n\t\t}\n\t};\n\t\n\tpublic static String getTenant(){\n\t\treturn MultiTenantHolder.get();\n\t}\n\t\n\tpublic static void setTenant(String tenantId){\n\t\tMultiTenantHolder.set(tenantId);\n\t}\n\t\n\tpublic static void removeThread(){\n\t\tMultiTenantHolder.remove();\n\t}\n\n}\n```\n\n现在我们可以用`MultiTenant.setTenant(tenantId)`来切换租户，而`MultiTenant.getTenant()`则为`TenantIdResolver`和`SchemaBasedMultiTenantConnectionProvider`提供标识。\n\n注意我在这里使用了`ThreadLocal`而不是静态属性，这是因为当请求并发时静态属性会被覆盖，然后就会导致租户之间切换串号，而`ThreadLocal`就不会有这样的问题。\n\n建议大家在Spring MVC的`Interceptor`或其他框架的filter里，根据用户请求的token或session获取租户标识后直接用`MultiTenant.setTenant(tenantId)`把数据源和Schema切换好，这样在具体的业务代码里就不需要每个方法都切换一次了，除非有特殊情况。\n\n# 5. 总结\n\n其实对于SaaS模式来说，难点通常不在技术方面，SaaS这么多年之所以一直不太火，主要还是在产品和营销策略方面很难找到突破口。\n\nSaaS软件多为企业级应用，这类应用的特点就是业务复杂、架构庞大，而大部分公司开发的Web端SaaS产品，质量上都不如同类客户端产品，做的比较牛的SaaS产品基本都是外国公司的。\n\n想要做好SaaS产品，还需要在产品上做更深入的打磨，希望国内做这方面的公司不要只顾求快，企业用户往往更看重质量。\n\n全文完。\n\n转载时请注明 **原作者 A.I.Roland (博客地址：https://airoland.github.io/)** ，并附上 **原文链接** ，谢谢！",
    "abstract": "其实SaaS也发展了N多年了，但一直以来都不是很火，不同的人可能对SaaS也有不同的理解。就我个人的理解，十几年前我们做IT卖产品，尤其是企业级产品时，通常都需要到客户的现场去实施，客户需要准备一个独立机房，软件大多是部署在客户的局域网上，而后续的更新和维护通常也需要持续跟进并到现场解决问题。在那个年代，云服务器还只是一个概念，毕竟基础设施差的太多了，性价比也完全不够。随着硬件技术的发展和性价比的提高，IaaS疯狂生长，软件开发商们发现可以把产品部署在云端，让客户以付费租赁的方式按需购买产品（变成了租户），软件开发商提供统一的更新和维护服务（公有云），或租户花更多的钱来获得独享的功能和服务（私有云），租户不需要再费力自己搭建机房，软件开发商也不需要为每个租户都安排实施专员，由此便产生了SaaS的概念。后面随着Spring Cloud等分布式微服务体系的出现，“混合云”也进入到了人们的视野。",
    "html": "<ul><li><a href=\"javascript:document.getElementById('1-').scrollIntoView()\">1. 概述</a></li>\n<li><a href=\"javascript:document.getElementById('2-').scrollIntoView()\">2. 方案比较</a>\n<ul><li><a href=\"javascript:document.getElementById('2-1-schema-').scrollIntoView()\">2.1 Schema？</a></li>\n<li><a href=\"javascript:document.getElementById('2-2-mysql-').scrollIntoView()\">2.2 MySQL的情况</a></li>\n<li><a href=\"javascript:document.getElementById('2-3-').scrollIntoView()\">2.3 优缺点</a>\n</li>\n</ul>\n</li><li><a href=\"javascript:document.getElementById('3-').scrollIntoView()\">3. 数据库架构设计</a>\n<ul><li><a href=\"javascript:document.getElementById('3-1-').scrollIntoView()\">3.1 分布式多租户</a></li>\n<li><a href=\"javascript:document.getElementById('3-2-').scrollIntoView()\">3.2 如何定位租户？</a></li>\n<li><a href=\"javascript:document.getElementById('3-3-').scrollIntoView()\">3.3 独立的数据服务</a>\n</li>\n</ul>\n</li><li><a href=\"javascript:document.getElementById('4-').scrollIntoView()\">4. 具体实现</a>\n<ul><li><a href=\"javascript:document.getElementById('4-1-hibernate-multi-tenancy').scrollIntoView()\">4.1 Hibernate Multi-tenancy</a></li>\n<li><a href=\"javascript:document.getElementById('4-2-tenantidresolver').scrollIntoView()\">4.2 TenantIdResolver</a></li>\n<li><a href=\"javascript:document.getElementById('4-3-schemabasedmultitenantconnectionprovider').scrollIntoView()\">4.3 SchemaBasedMultiTenantConnectionProvider</a></li>\n<li><a href=\"javascript:document.getElementById('4-4-multitenant').scrollIntoView()\">4.4 MultiTenant</a>\n</li>\n</ul>\n</li><li><a href=\"javascript:document.getElementById('5-').scrollIntoView()\">5. 总结</a></li>\n</ul>\n\n<h1 id=\"1-\">1. 概述</h1>\n<p>其实SaaS也发展了N多年了，但一直以来都不是很火，不同的人可能对SaaS也有不同的理解。就我个人的理解，十几年前我们做IT卖产品，尤其是企业级产品时，通常都需要<strong>到客户的现场去实施</strong>，客户需要准备一个独立机房，软件大多是部署在客户的局域网上，而后续的更新和维护通常也需要持续跟进并到现场解决问题。在那个年代，云服务器还只是一个概念，毕竟基础设施差的太多了，性价比也完全不够。</p>\n<p>随着硬件技术的发展和性价比的提高，IaaS疯狂生长，软件开发商们发现可以把产品部署在云端，让客户以付费租赁的方式按需购买产品（变成了租户），软件开发商提供统一的更新和维护服务（公有云），或租户花更多的钱来获得独享的功能和服务（私有云），租户不需要再费力自己搭建机房，软件开发商也不需要为每个租户都安排实施专员，由此便产生了SaaS的概念。后面随着Spring Cloud等分布式微服务体系的出现，“混合云”也进入到了人们的视野。</p>\n<p>那么SaaS服务的关键就在于，以前客户是在自己的局域网里玩，数据有绝对的隔离性，功能可以随意定制。现在放到了互联网上，他变成了租户，你作为服务提供商如何向他保证他的数据是隔离的，他的功能是可以定制的？</p>\n<p>数据的隔离就意味着租户们的数据不应混合在一起，当然你可以说混合在一起后用租户ID来区分，然后让使用者感受起来是隔离的就好了（毕竟黑箱），但如此一来对指定租户的备份和恢复就变得相当困难，数据量大了以后分表分库或横向扩展的问题会暴露无遗，另外当租户需要定制化功能时，就意味着有很大可能他需要一套特殊的表，你会发现你的开发难度将呈几何级数增长。</p>\n<p>下面我们就来讨论一下SaaS模式的数据库设计有哪些方案。</p>\n<h1 id=\"2-\">2. 方案比较</h1>\n<p>目前主流的SaaS多租户数据库方案有以下三种：</p>\n<p><img src=\"http://airoland.github.io/data/article/20170901175128034/1.png\" alt=\"image\"></p>\n<p>它们各自的特点为：</p>\n<ul>\n<li>完全隔离：可以理解为一个租户一个数据库，比如一个租户一个Oracle或MySQL实例，硬件成本过高，属于土豪玩法；</li>\n<li>独立Schema：即一个租户一个Schema，多个Schema共享一个数据库，属于成本和需求的折衷方案；</li>\n<li>完全共享：即上文概述中提到的所有数据都混合在一起。</li>\n</ul>\n<p>通常情况下我推荐大家使用折衷方案，即共享数据库，独立Schema，既满足了数据隔离，又降低了开发和硬件成本。</p>\n<h2 id=\"2-1-schema-\">2.1 Schema？</h2>\n<p>有的人不了解Schema是什么，其实很多数据库中都有Schema的概念，或许他们严格意义上有略微差别，但从抽象层面上讲，当我们提到Schema时，我们指的都是同一个概念：</p>\n<p><img src=\"http://airoland.github.io/data/article/20170901175128034/2.png\" alt=\"image\"></p>\n<h2 id=\"2-2-mysql-\">2.2 MySQL的情况</h2>\n<p>Schema通常有一些等价概念，比如在互联网公司常用的MySQL数据库里，Schema和Database就是等价的：</p>\n<p><img src=\"http://airoland.github.io/data/article/20170901175128034/3.png\" alt=\"image\"></p>\n<p>也就是说，MySQL的服务实例才等同于Oracle的数据库，而MySQL的数据库（Database）其实是一个比较小的概念，这一点希望大家注意。</p>\n<h2 id=\"2-3-\">2.3 优缺点</h2>\n<p><img src=\"http://airoland.github.io/data/article/20170901175128034/4.png\" alt=\"image\"></p>\n<p>下面我们边设计架构边解决已知的缺陷。</p>\n<h1 id=\"3-\">3. 数据库架构设计</h1>\n<h2 id=\"3-1-\">3.1 分布式多租户</h2>\n<p><strong>第一个问题：假设有10万个租户怎么办？</strong></p>\n<p>首先，10万个Schema肯定不能放在同一台机器上，既然我们采取了独立Schema的方式，那么横向扩展的优势就立即显现出来了：</p>\n<p><img src=\"http://airoland.github.io/data/article/20170901175128034/5.png\" alt=\"image\"></p>\n<p>注意，每个节点下面其实是一个数据库集群，每个集群都可以使用<code>PXC</code>或<code>Master-Slave</code>等方案来维护同一套数据，保证数据库的高可用。对于这样的一个数据库集群，我们可以称之为一个数据源，即我不管这个数据源的集群下有多少台机器，但这个数据源的数据肯定是一致的。所有这些数据源综合起来，就是<strong>SaaS分布式多租户数据库集群</strong>。</p>\n<h2 id=\"3-2-\">3.2 如何定位租户？</h2>\n<p>当我们采用分布式存储之后，如何来定位租户呢？举个例子：</p>\n<p><img src=\"http://airoland.github.io/data/article/20170901175128034/6.png\" alt=\"image\"></p>\n<p>即我们可以通过映射表或算法的方式，来找到租户对应的数据源和数据源下的Schema。具体怎么切换见下文第4章。</p>\n<h2 id=\"3-3-\">3.3 独立的数据服务</h2>\n<p><strong>第二个问题：如何进行批量操作（更新维护Schema、统计分析等）？</strong></p>\n<p>当租户较少的时候，我们可以通过搭建独立的数据服务来完成这些功能：</p>\n<p><img src=\"http://airoland.github.io/data/article/20170901175128034/7.png\" alt=\"image\"></p>\n<p>具体来说：</p>\n<ul>\n<li>新增租户：可以执行指定的SQL脚本文件来动态创建Schema；</li>\n<li>更新维护：可以为指定的Schema集合或全部Schema执行某条SQL语句或脚本文件（刷库），来更新维护表结构或数据；</li>\n<li>统计分析：如果是为租户提供他自身数据的统计分析，那么很简单只操作它自己的Schema就够了。如果是为租户或服务商提供全局统计分析，那就需要异步聚合所有Schema的数据。</li>\n</ul>\n<p>但问题来了，当租户达到10万或更多级别的时候，上面的做法肯定会带来性能和等待的问题，还有没有更优化的方法？</p>\n<p><strong>1. 分区刷库</strong></p>\n<p>首先，我们需要把数据服务按功能拆分成粒度更细的微服务，比如批量刷库微服务，将性能的损耗分布到不同机器上。</p>\n<p>然后启动多个批量刷库微服务实例，每个实例负责不同区域的刷库，比如A负责第1-3000租户，B负责第3001-6000等等，这样并发刷库就可以节省总体更新维护的时间了。</p>\n<p><strong>2. 统计分析</strong></p>\n<p>这个基本属于发挥人民群众智慧的时候了，基本没有最优的方案，你可以先分区聚合统计分析一波，然后再把分区结果整体聚合统计分析出最终结果。也可以把数据通过Sqoop导出，然后用Spark或Storm来分析。</p>\n<p>通常情况下，租户都只关注他自身数据的统计分析，所以对于这类需求，基本是可以做到实时的。而一般关注全局数据的都是SaaS服务提供商，对于时效性的要求其实是可以降低的。</p>\n<h1 id=\"4-\">4. 具体实现</h1>\n<p>对于切换数据源和切换Schema的实现有多种方式，比如经典的<strong>二级域名泛解析</strong>————每个租户有独立的二级域名，后端通过访问的域名来识别租户。</p>\n<p>在这里我将介绍另外一种方案，它基于Hibernate在4.0加入的<code>Multi-tenancy</code>模式，并进行了一定的拓展。或许现在用Mybatis人占多数，但如果你在用更方便的Spring Data JPA，那么它是基于Hibernate的上层封装，你可以直接使用它的<code>Multi-tenancy</code>功能。</p>\n<h2 id=\"4-1-hibernate-multi-tenancy\">4.1 Hibernate Multi-tenancy</h2>\n<p>首先我们要配置Hibernate开启<code>Multi-tenancy</code>模式，由于Spring Boot的YAML配置尚不支持<code>Multi-tenancy</code>属性，因此我们只能使用XML或Java类来设置。</p>\n<p>假设现在我们用XML来配置Hibernate的<code>entityManagerFactory</code>，那么在<code>jpaProperties</code>我们就可以添加属性如下：</p>\n<pre><code>&lt;prop key=<span class=\"hljs-string\">\"hibernate.multiTenancy\"</span>&gt;SCHEMA&lt;/prop&gt;\n&lt;prop key=<span class=\"hljs-string\">\"hibernate.tenant_identifier_resolver\"</span>&gt;com<span class=\"hljs-selector-class\">.xxx</span><span class=\"hljs-selector-class\">.tenant</span><span class=\"hljs-selector-class\">.TenantIdResolver</span>&lt;/prop&gt;\n&lt;prop key=<span class=\"hljs-string\">\"hibernate.multi_tenant_connection_provider\"</span>&gt;com<span class=\"hljs-selector-class\">.xxx</span><span class=\"hljs-selector-class\">.tenant</span><span class=\"hljs-selector-class\">.SchemaBasedMultiTenantConnectionProvider</span>&lt;/prop&gt;\n</code></pre><p>其中<code>hibernate.multiTenancy</code>属性表示你要使用的多租户模式，有三个值：<code>DATABASE</code>，<code>SCHEMA</code>和<code>DISCRIMINATOR</code>（5.0实现），分别对应我们在第2章提到的三种数据库方案：独立数据库、独立Schema和完全共享，在这里我们取值<code>SCHEMA</code>。</p>\n<p><code>hibernate.tenant_identifier_resolver</code>表示指定租户身份解析器的实现类。</p>\n<p><code>hibernate.multi_tenant_connection_provider</code>表示指定多租户连接器的实现类。</p>\n<h2 id=\"4-2-tenantidresolver\">4.2 TenantIdResolver</h2>\n<p>此实现类代码如下：</p>\n<pre><code><span class=\"hljs-keyword\">import</span> org.hibernate.context.spi.CurrentTenantIdentifierResolver;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">TenantIdResolver</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">CurrentTenantIdentifierResolver</span> </span>{\n\n    <span class=\"hljs-comment\">// 此方法返回当前的租户标识</span>\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\">String <span class=\"hljs-title\">resolveCurrentTenantIdentifier</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">return</span> MultiTenant.<span class=\"hljs-title\">getTenant</span><span class=\"hljs-params\">()</span></span>;\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">validateExistingCurrentSessions</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n    }\n\n}\n</code></pre><p><code>MultiTenant.getTenant()</code>会在第4.4节中讲解。</p>\n<h2 id=\"4-3-schemabasedmultitenantconnectionprovider\">4.3 SchemaBasedMultiTenantConnectionProvider</h2>\n<p>这个实现类里我使用<code>HikariCP</code>作为连接池，然后通过切换连接池的方式切换数据源，本例中演示了两个数据源，大家可以自己思考如何实现更多数据源的管理。我在代码中的注释大家一定要仔细看：</p>\n<pre><code><span class=\"hljs-keyword\">import</span> java.sql.Connection;\n<span class=\"hljs-keyword\">import</span> java.sql.SQLException;\n<span class=\"hljs-keyword\">import</span> java.util.HashMap;\n<span class=\"hljs-keyword\">import</span> java.util.Map;\n\n<span class=\"hljs-keyword\">import</span> org.hibernate.HibernateException;\n<span class=\"hljs-keyword\">import</span> org.hibernate.engine.jdbc.connections.spi.MultiTenantConnectionProvider;\n<span class=\"hljs-keyword\">import</span> org.hibernate.hikaricp.internal.HikariCPConnectionProvider;\n<span class=\"hljs-keyword\">import</span> org.hibernate.service.spi.Configurable;\n<span class=\"hljs-keyword\">import</span> org.hibernate.service.spi.Stoppable;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SchemaBasedMultiTenantConnectionProvider</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">MultiTenantConnectionProvider</span>, <span class=\"hljs-title\">Stoppable</span>, <span class=\"hljs-title\">Configurable</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">long</span> serialVersionUID = <span class=\"hljs-number\">1</span>L;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> HikariCPConnectionProvider connectionProvider1 = <span class=\"hljs-keyword\">new</span> HikariCPConnectionProvider();\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> HikariCPConnectionProvider connectionProvider2 = <span class=\"hljs-keyword\">new</span> HikariCPConnectionProvider();\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> Map&lt;String,HikariCPConnectionProvider&gt; tenantIdConnMap = <span class=\"hljs-keyword\">new</span> HashMap&lt;String,HikariCPConnectionProvider&gt;();\n\n    <span class=\"hljs-comment\">// 动态获取数据源连接池</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-function\">HikariCPConnectionProvider <span class=\"hljs-title\">getProvider</span><span class=\"hljs-params\">()</span></span>{\n        String tenantIdentifier = MultiTenant.getTenant();\n        tenantIdentifier = tenantIdentifier.split(<span class=\"hljs-string\">\":\"</span>)[<span class=\"hljs-number\">0</span>];\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">return</span> tenantIdConnMap.<span class=\"hljs-title\">get</span><span class=\"hljs-params\">(tenantIdentifier)</span></span>;\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\">Connection <span class=\"hljs-title\">getAnyConnection</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> SQLException </span>{\n        <span class=\"hljs-keyword\">return</span> getProvider().getConnection();\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">releaseAnyConnection</span><span class=\"hljs-params\">(Connection connection)</span> <span class=\"hljs-keyword\">throws</span> SQLException </span>{\n        getProvider().closeConnection(connection);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\">Connection <span class=\"hljs-title\">getConnection</span><span class=\"hljs-params\">(String tenantIdentifier)</span> <span class=\"hljs-keyword\">throws</span> SQLException </span>{\n        tenantIdentifier = tenantIdentifier.split(<span class=\"hljs-string\">\":\"</span>)[<span class=\"hljs-number\">1</span>];\n        <span class=\"hljs-keyword\">final</span> Connection connection = getAnyConnection();\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-comment\">// 在这里可以看到其本质就是执行了USE语句</span>\n            connection.createStatement().execute(<span class=\"hljs-string\">\"USE \"</span> + tenantIdentifier);\n        } <span class=\"hljs-keyword\">catch</span> (SQLException e) {\n            e.printStackTrace();\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> HibernateException(<span class=\"hljs-string\">\"Could not alter JDBC connection to specified schema [\"</span> + tenantIdentifier\n                    + <span class=\"hljs-string\">\"]\"</span>, e);\n        }\n        <span class=\"hljs-keyword\">return</span> connection;\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">releaseConnection</span><span class=\"hljs-params\">(String tenantIdentifier, Connection connection)</span> <span class=\"hljs-keyword\">throws</span> SQLException </span>{\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-comment\">// 释放连接时移到release_connection空库，防止出现异常</span>\n            <span class=\"hljs-comment\">// 此处要特别注意，一定要USE一个已经存在的库，否则连接不会释放</span>\n            connection.createStatement().execute(<span class=\"hljs-string\">\"USE release_connection\"</span>);\n        } <span class=\"hljs-keyword\">catch</span> (SQLException e) {\n            e.printStackTrace();\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> HibernateException(<span class=\"hljs-string\">\"Could not alter JDBC connection to specified schema [\"</span> + tenantIdentifier\n                    + <span class=\"hljs-string\">\"]\"</span>, e);\n        }\n        getProvider().closeConnection(connection);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">isUnwrappableAs</span><span class=\"hljs-params\">(Class unwrapType)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.getProvider().isUnwrappableAs(unwrapType);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> &lt;T&gt; <span class=\"hljs-function\">T <span class=\"hljs-title\">unwrap</span><span class=\"hljs-params\">(Class&lt;T&gt; unwrapType)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.getProvider().unwrap(unwrapType);\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">stop</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.getProvider().stop();\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-title\">supportsAggressiveRelease</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.getProvider().supportsAggressiveRelease();\n    }\n\n    <span class=\"hljs-meta\">@SuppressWarnings</span>({ <span class=\"hljs-string\">\"unchecked\"</span>, <span class=\"hljs-string\">\"rawtypes\"</span> })\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">configure</span><span class=\"hljs-params\">(Map configurationValues)</span> </span>{\n\n        <span class=\"hljs-comment\">// connectorProvider初始化，假设第一个数据源已在配置文件中写好</span>\n        <span class=\"hljs-keyword\">this</span>.connectionProvider1.configure(configurationValues);\n\n        <span class=\"hljs-comment\">// 第二个数据源的配置</span>\n        configurationValues.put(<span class=\"hljs-string\">\"hibernate.connection.url\"</span>, <span class=\"hljs-string\">\"jdbc:mysql://192.168.1.2:3306/test?characterEncoding=UTF-8&amp;useSSL=false\"</span>);\n        configurationValues.put(<span class=\"hljs-string\">\"hibernate.connection.username\"</span>, <span class=\"hljs-string\">\"root\"</span>);\n        configurationValues.put(<span class=\"hljs-string\">\"hibernate.connection.password\"</span>, <span class=\"hljs-string\">\"123456\"</span>);\n        configurationValues.put(<span class=\"hljs-string\">\"hibernate.hikari.dataSource.password\"</span>, <span class=\"hljs-string\">\"123456\"</span>);\n        <span class=\"hljs-keyword\">this</span>.connectionProvider2.configure(configurationValues);\n\n        <span class=\"hljs-comment\">// connectorProvider与数据源的关系映射</span>\n        tenantIdConnMap.put(<span class=\"hljs-string\">\"dataSource1\"</span>, connectionProvider1);\n        tenantIdConnMap.put(<span class=\"hljs-string\">\"dataSource2\"</span>, connectionProvider2);\n    }\n\n}\n</code></pre><h2 id=\"4-4-multitenant\">4.4 MultiTenant</h2>\n<p>这个类提供了设置和获取租户标识的方法，以保证后续的业务处理在指定的租户上。假设我们的租户标识格式为“数据源:Schema”，那么此类实现如下：</p>\n<pre><code><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MultiTenant</span> {\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> ThreadLocal&lt;String&gt; MultiTenantHolder = <span class=\"hljs-keyword\">new</span> ThreadLocal&lt;String&gt;() {\n        @<span class=\"hljs-function\">Override\n        <span class=\"hljs-keyword\">protected</span> String <span class=\"hljs-title\">initialValue</span>(<span class=\"hljs-params\"></span>) </span>{\n            String tenantId = <span class=\"hljs-literal\">null</span>;\n            <span class=\"hljs-keyword\">try</span> {  \n                tenantId = <span class=\"hljs-string\">\"dataSource1:test\"</span>; \n            } <span class=\"hljs-keyword\">catch</span> (Exception e) {  \n                e.printStackTrace();  \n            }  \n            <span class=\"hljs-keyword\">return</span> tenantId;\n        }\n    };\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title\">getTenant</span>(<span class=\"hljs-params\"></span>)</span>{\n        <span class=\"hljs-keyword\">return</span> MultiTenantHolder.<span class=\"hljs-keyword\">get</span>();\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setTenant</span>(<span class=\"hljs-params\">String tenantId</span>)</span>{\n        MultiTenantHolder.<span class=\"hljs-keyword\">set</span>(tenantId);\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">removeThread</span>(<span class=\"hljs-params\"></span>)</span>{\n        MultiTenantHolder.<span class=\"hljs-keyword\">remove</span>();\n    }\n\n}\n</code></pre><p>现在我们可以用<code>MultiTenant.setTenant(tenantId)</code>来切换租户，而<code>MultiTenant.getTenant()</code>则为<code>TenantIdResolver</code>和<code>SchemaBasedMultiTenantConnectionProvider</code>提供标识。</p>\n<p>注意我在这里使用了<code>ThreadLocal</code>而不是静态属性，这是因为当请求并发时静态属性会被覆盖，然后就会导致租户之间切换串号，而<code>ThreadLocal</code>就不会有这样的问题。</p>\n<p>建议大家在Spring MVC的<code>Interceptor</code>或其他框架的filter里，根据用户请求的token或session获取租户标识后直接用<code>MultiTenant.setTenant(tenantId)</code>把数据源和Schema切换好，这样在具体的业务代码里就不需要每个方法都切换一次了，除非有特殊情况。</p>\n<h1 id=\"5-\">5. 总结</h1>\n<p>其实对于SaaS模式来说，难点通常不在技术方面，SaaS这么多年之所以一直不太火，主要还是在产品和营销策略方面很难找到突破口。</p>\n<p>SaaS软件多为企业级应用，这类应用的特点就是业务复杂、架构庞大，而大部分公司开发的Web端SaaS产品，质量上都不如同类客户端产品，做的比较牛的SaaS产品基本都是外国公司的。</p>\n<p>想要做好SaaS产品，还需要在产品上做更深入的打磨，希望国内做这方面的公司不要只顾求快，企业用户往往更看重质量。</p>\n<p>全文完。</p>\n<p>转载时请注明 <strong>原作者 A.I.Roland (博客地址：<a href=\"https://airoland.github.io/\">https://airoland.github.io/</a>)</strong> ，并附上 <strong>原文链接</strong> ，谢谢！</p>\n"
}