{
    "title": "Vue.js 小型状态管理——中央事件总线",
    "time": "2017/06/29 12:05:44",
    "tags": ["Vue.js"],
    "content": "[TOC]\n\n# 1. 概述\n\n通常情况下，我们在使用`Vue.js`开发中大型SPA项目时，都会把`Vuex`作为状态管理工具。但仔细看过官方文档的朋友应该会发现，在小型SPA项目中尤雨溪并不推荐使用`Vuex`来做状态管理，毕竟“杀鸡焉用牛刀”。\n\n那么此时我们就可以使用一个简单的**中央事件总线**来做小型状态管理。\n\n**注意：本文使用的`Vue.js`、`Vue-Router`均为2.x版本。**\n\n# 2. 如何使用\n\n在`Vue.js`2.x官方文档的[Non Parent-Child Communication](https://vuejs.org/v2/guide/components.html#Non-Parent-Child-Communication)小节中，介绍了可以使用一个空的`Vue`实例作为中央事件总线来提供组件间的通信。\n\n现在我们就来给它做一下与官方不一样的扩展。\n\n## 2.1 Bus\n\n首先声明一个`Vue`实例，由于我们需要的是全局状态/事件管理，因此更适合在`window`对象上操作：\n\n```\nwindow.bus = new Vue();\n```\n\n接下来就可以向`bus`中添加你想要管理的状态（数据）了，示例：\n\n```\nwindow.bus = new Vue({\n    data: {\n        count: 0\n    }\n});\n```\n\n需要注意的是，这里的`data`不是在组件中，**不要将其写成函数的形式**。\n\n接下来可以在任意组件中测试一下：\n\n```\nconsole.log(bus.count);  // 0\nbus.count++;\nconsole.log(bus.count);  // 1\n```\n\n## 2.2 状态\n\n### 2.2.1 状态更改\n\n从上面的例子中我们看到，`bus`中的状态是可以直接赋值更新的，比如我们可以直接执行``bus.num = 9;``。但这种代码多了以后会造成状态管理的混乱，因为到后面你可能无法知道在何时何地赋了什么样的值。\n\n在这里我建议大家不要直接操作状态的值，而是像`Vuex`一样，通过方法来操作状态。比如可以**通过特定方法来限制状态改变的方式**：\n\n```\nwindow.bus = new Vue({\n    data: {\n        count: 0\n    },\n    methods: {\n        increment() {\n            this.count++;\n        },\n        decrement() {\n            this.count--;\n        }\n    }\n});\n```\n\n如果我们只用`increment`和`decrement`来操作状态，那么`count`的变化就是有据可循的，不会出现突然在某处被赋成一个奇怪的值的情况：\n\n```\nconsole.log(bus.count);  // 0\nbus.increment();\nconsole.log(bus.count);  // 1\nbus.decrement();\nconsole.log(bus.count);  // 0\n```\n\n当然，这种使用方式只是建议，大家可以根据自身习惯做选择。\n\n### 2.2.2 在组件中获取状态\n\n首先，在组件的模板中是无法直接使用`bus`的，比如下面这种情况就会报错：\n\n```\n// *.vue单文件组件\n\n<template>\n<div>\n    <p>{{ bus.count }}</p>\n</div>\n</template>\n\n<script>\nexport default {}\n</script>\n```\n\n有的朋友可能会想到用组件的`data`来直接代理`bus`中的状态：\n\n```\n<template>\n<div>\n    <p>{{ myCount }}</p>\n</div>\n</template>\n\n<script>\nexport default {\n    data () {\n        return {\n            myCount: bus.count\n        }\n    }\n}\n</script>\n```\n\n这样`myCount`的确会获得`bus`中`count`的值，但并不会随着`bus.count`的改变而更新。因为组件中`myCount`的值会在组件挂载时直接获取`bus.count`的真实值，之后的事情就与`bus.count`无关了。\n\n所以正确的做法是在计算属性中处理：\n\n```\n<template>\n<div>\n    <p>{{ myCount }}</p>\n</div>\n</template>\n\n<script>\nexport default {\n    computed: {\n        myCount () {\n            return bus.count;\n        }\n    }\n}\n</script>\n```\n\n此时`myCount`的值会随着`bus.count`的改变而更新了。在这里我也建议大家，在组件中的任何地方使用状态时，应采取`this.myCount`计算属性的方式，而不要直接使用`bus.count`。\n\n## 2.3 事件\n\n官方文档中其实对`bus`的事件方面已经举了例子：\n\n```\n// 在 A 组件中触发\nbus.$emit('id-selected', 1)\n\n// 在 B 组件中监听\nbus.$on('id-selected', function (id) {\n  // ...\n})\n```\n\n其实我们还可以有一些扩展玩法，假设我写了一个**底部按钮**组件`footerButton`：\n\n```\n// footer-button.vue\n\n<template>\n<footer>\n    <button type=\"button\" @click=\"btnClick\">{{ btnText }}</button>\n</footer>\n</template>\n\n<script>\nexport default {\n    data () {\n        return {\n            btnText: 'Button'        \n        }\n    },\n    methods: {\n        btnClick() {\n            // 点击事件\n        }\n    }\n}\n</script>\n```\n\n现在我希望在每个页面都复用这个组件，那在使用`Vue-Router`的情况下，我的根组件模板结构可能是这样的：\n\n```\n<template>\n<div class=\"main\">\n    <keep-alive>\n        <router-view name=\"content\"></router-view>\n    </keep-alive>\n    <footer-button></footer-button>\n</div>\n</template>\n\n<script>\nimport footerButton from './components/footer-button.vue'\n\nexport default {\n    components: {\n        footerButton\n    }\n}\n</script>\n```\n\n那么我想要的效果是，当`router`切换到不同组件时，我的底部按钮组件的文本和点击事件都能随之变化，保持其业务相关性。\n\n可以看到，`footerButton`组件和`router`切换的组件是兄弟组件，即非父子组件。那么它们之间的状态及事件联动，就可以用`bus`来实现，首先声明`bus`：\n\n```\nwindow.bus = new Vue({\n    data: {\n        btnText: ''\n    },\n    methods: {\n        setBtnText (text) {\n            this.btnText = text;\n        }\n    }\n});\n```\n\n接下来改造`footerButton`：\n\n```\n// footer-button.vue\n\n<template>\n<footer>\n    <button type=\"button\" @click=\"btnClick\">{{ btnText }}</button>\n</footer>\n</template>\n\n<script>\nexport default {\n    computed: {\n        btnText () {\n            return bus.btnText;\n        }\n    },\n    methods: {\n        btnClick() {\n            bus.$emit('btnClick');\n        }\n    }\n}\n</script>\n```\n\n此时底部按钮的文本已经和`bus.btnText`绑定在一起，而点击事件则由`bus`来触发一个名为`btnClick`的事件。\n\n既然我们要对每个`router`切换到的组件做不同处理，那么`bus.btnText`的修改以及`btnClick`的监听都应该在**要切换到的组件**中声明，现假设有A、B两个用于切换的组件，以A组件为例：\n\n```\n// A.vue\n\n<script>\nexport default {\n    ...\n    beforeRouteEnter (to, from, next) {\n        bus.setBtnText('A Button');\n        next(vm => {\n            bus.$off('btnClick');\n            bus.$on('btnClick', function () {\n                // 点击事件\n            })\n        });\n    },\n    ...\n}\n</script>\n```\n\n这里我们在`beforeRouteEnter`导航钩子中做处理，首先修改了按钮的文本为`A Button`，随后在`next`中监听事件，这是因为此钩子中不能直接获取组件实例`this`，只能在`next`的回调中通过`vm`访问。另外在监听事件前用`off`先移除监听，可以防止重复监听同一事件。\n\n如果有后端基础（尤其是OOP编程经验）的朋友可能会发现，我们上面做的底部按钮的实现，其实很像OOP中**接口实现多态**的思想。可以这样说，`btnClick`作为`bus`接口中的方法，在不同的组件中有不同实现，而`footerButton`在调用`bus`的`btnClick`方法时并不关心具体实现。仔细想来也是颇有意思的事情。\n\n# 3. 小结\n\n本文简要描述了如何在不使用`Vuex`的情况下做状态管理，`bus`作为一个完整的Vue实例，其实是可以做许多事情的，比如我们可以直接在`bus`中定义计算属性：\n\n```\nwindow.bus = new Vue({\n    data: {\n        count: 1\n    },\n    computed: {\n        tenfold () {\n            return this.count * 10;\n        }\n    }\n});\n```\n\n然后在其他组件中直接获取`bus.tenfold`即可，大家可以尽情发挥想象力。\n\n我们在实现`bus`的过程中，其实也可以一窥`Vuex`的许多设计思想，比如`Vuex` 2.x中各组件也是在计算属性里获取状态，另外也会发现某些与后端思路较像的地方。\n\n实际上，无论前端还是后端，许多编程思想都是相通的，跟语言无关，希望大家能活学活用。\n\n全文完。\n\n转载时请注明 **原作者 A.I.Roland (博客地址：https://airoland.github.io/)** ，并附上 **原文链接** ，谢谢！",
    "abstract": "通常情况下，我们在使用Vue.js开发中大型SPA项目时，都会把Vuex作为状态管理工具。但仔细看过官方文档的朋友应该会发现，在小型SPA项目中尤雨溪并不推荐使用Vuex来做状态管理，毕竟“杀鸡焉用牛刀”。那么此时我们就可以使用一个简单的中央事件总线来做小型状态管理。在Vue.js2.x官方文档的小节中，介绍了可以使用一个空的Vue实例作为中央事件总线来提供组件间的通信...",
    "html": "<ul><li><a href=\"javascript:document.getElementById('1-').scrollIntoView()\">1. 概述</a></li>\n<li><a href=\"javascript:document.getElementById('2-').scrollIntoView()\">2. 如何使用</a>\n<ul><li><a href=\"javascript:document.getElementById('2-1-bus').scrollIntoView()\">2.1 Bus</a></li>\n<li><a href=\"javascript:document.getElementById('2-2-').scrollIntoView()\">2.2 状态</a>\n<ul><li><a href=\"javascript:document.getElementById('2-2-1-').scrollIntoView()\">2.2.1 状态更改</a></li>\n<li><a href=\"javascript:document.getElementById('2-2-2-').scrollIntoView()\">2.2.2 在组件中获取状态</a>\n</li>\n</ul>\n</li><li><a href=\"javascript:document.getElementById('2-3-').scrollIntoView()\">2.3 事件</a>\n</li>\n</ul>\n</li><li><a href=\"javascript:document.getElementById('3-').scrollIntoView()\">3. 小结</a></li>\n</ul>\n\n<h1 id=\"1-\">1. 概述</h1>\n<p>通常情况下，我们在使用<code>Vue.js</code>开发中大型SPA项目时，都会把<code>Vuex</code>作为状态管理工具。但仔细看过官方文档的朋友应该会发现，在小型SPA项目中尤雨溪并不推荐使用<code>Vuex</code>来做状态管理，毕竟“杀鸡焉用牛刀”。</p>\n<p>那么此时我们就可以使用一个简单的<strong>中央事件总线</strong>来做小型状态管理。</p>\n<p><strong>注意：本文使用的<code>Vue.js</code>、<code>Vue-Router</code>均为2.x版本。</strong></p>\n<h1 id=\"2-\">2. 如何使用</h1>\n<p>在<code>Vue.js</code>2.x官方文档的<a href=\"https://vuejs.org/v2/guide/components.html#Non-Parent-Child-Communication\">Non Parent-Child Communication</a>小节中，介绍了可以使用一个空的<code>Vue</code>实例作为中央事件总线来提供组件间的通信。</p>\n<p>现在我们就来给它做一下与官方不一样的扩展。</p>\n<h2 id=\"2-1-bus\">2.1 Bus</h2>\n<p>首先声明一个<code>Vue</code>实例，由于我们需要的是全局状态/事件管理，因此更适合在<code>window</code>对象上操作：</p>\n<pre><code><span class=\"hljs-built_in\">window</span>.bus = <span class=\"hljs-keyword\">new</span> Vue();\n</code></pre><p>接下来就可以向<code>bus</code>中添加你想要管理的状态（数据）了，示例：</p>\n<pre><code><span class=\"hljs-title\">window</span>.bus = new <span class=\"hljs-type\">Vue</span>({\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">data</span>: {\n        <span class=\"hljs-title\">count</span>: 0\n    }</span>\n});\n</code></pre><p>需要注意的是，这里的<code>data</code>不是在组件中，<strong>不要将其写成函数的形式</strong>。</p>\n<p>接下来可以在任意组件中测试一下：</p>\n<pre><code>console.<span class=\"hljs-built_in\">log</span>(bus.<span class=\"hljs-built_in\">count</span>);  <span class=\"hljs-comment\">// 0</span>\nbus.<span class=\"hljs-built_in\">count</span>++;\nconsole.<span class=\"hljs-built_in\">log</span>(bus.<span class=\"hljs-built_in\">count</span>);  <span class=\"hljs-comment\">// 1</span>\n</code></pre><h2 id=\"2-2-\">2.2 状态</h2>\n<h3 id=\"2-2-1-\">2.2.1 状态更改</h3>\n<p>从上面的例子中我们看到，<code>bus</code>中的状态是可以直接赋值更新的，比如我们可以直接执行<code>bus.num = 9;</code>。但这种代码多了以后会造成状态管理的混乱，因为到后面你可能无法知道在何时何地赋了什么样的值。</p>\n<p>在这里我建议大家不要直接操作状态的值，而是像<code>Vuex</code>一样，通过方法来操作状态。比如可以<strong>通过特定方法来限制状态改变的方式</strong>：</p>\n<pre><code>window.bus = <span class=\"hljs-keyword\">new</span> Vue({\n    data: {\n        <span class=\"hljs-keyword\">count</span>: <span class=\"hljs-number\">0</span>\n    },\n    methods: {\n        increment() {\n            <span class=\"hljs-keyword\">this</span>.<span class=\"hljs-keyword\">count</span>++;\n        },\n        decrement() {\n            <span class=\"hljs-keyword\">this</span>.<span class=\"hljs-keyword\">count</span>--;\n        }\n    }\n});\n</code></pre><p>如果我们只用<code>increment</code>和<code>decrement</code>来操作状态，那么<code>count</code>的变化就是有据可循的，不会出现突然在某处被赋成一个奇怪的值的情况：</p>\n<pre><code>console.<span class=\"hljs-built_in\">log</span>(bus.<span class=\"hljs-built_in\">count</span>);  <span class=\"hljs-comment\">// 0</span>\nbus.increment();\nconsole.<span class=\"hljs-built_in\">log</span>(bus.<span class=\"hljs-built_in\">count</span>);  <span class=\"hljs-comment\">// 1</span>\nbus.decrement();\nconsole.<span class=\"hljs-built_in\">log</span>(bus.<span class=\"hljs-built_in\">count</span>);  <span class=\"hljs-comment\">// 0</span>\n</code></pre><p>当然，这种使用方式只是建议，大家可以根据自身习惯做选择。</p>\n<h3 id=\"2-2-2-\">2.2.2 在组件中获取状态</h3>\n<p>首先，在组件的模板中是无法直接使用<code>bus</code>的，比如下面这种情况就会报错：</p>\n<pre><code><span class=\"xml\">// *.vue单文件组件\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span></span><span class=\"hljs-template-variable\">{{ bus.count }</span><span class=\"xml\">}<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> </span></span><span class=\"hljs-template-variable\">{}</span><span class=\"xml\"><span class=\"undefined\">\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n</code></pre><p>有的朋友可能会想到用组件的<code>data</code>来直接代理<code>bus</code>中的状态：</p>\n<pre><code><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span></span><span class=\"hljs-template-variable\">{{ myCount }}</span><span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n    data () {\n        <span class=\"hljs-keyword\">return</span> {\n            <span class=\"hljs-attr\">myCount</span>: bus.count\n        }\n    }\n}\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n</code></pre><p>这样<code>myCount</code>的确会获得<code>bus</code>中<code>count</code>的值，但并不会随着<code>bus.count</code>的改变而更新。因为组件中<code>myCount</code>的值会在组件挂载时直接获取<code>bus.count</code>的真实值，之后的事情就与<code>bus.count</code>无关了。</p>\n<p>所以正确的做法是在计算属性中处理：</p>\n<pre><code><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span></span><span class=\"hljs-template-variable\">{{ myCount }}</span><span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n    <span class=\"hljs-attr\">computed</span>: {\n        myCount () {\n            <span class=\"hljs-keyword\">return</span> bus.count;\n        }\n    }\n}\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n</code></pre><p>此时<code>myCount</code>的值会随着<code>bus.count</code>的改变而更新了。在这里我也建议大家，在组件中的任何地方使用状态时，应采取<code>this.myCount</code>计算属性的方式，而不要直接使用<code>bus.count</code>。</p>\n<h2 id=\"2-3-\">2.3 事件</h2>\n<p>官方文档中其实对<code>bus</code>的事件方面已经举了例子：</p>\n<pre><code><span class=\"hljs-comment\">// 在 A 组件中触发</span>\nbus.$emit(<span class=\"hljs-string\">'id-selected'</span>, <span class=\"hljs-number\">1</span>)\n\n<span class=\"hljs-comment\">// 在 B 组件中监听</span>\nbus.$on(<span class=\"hljs-string\">'id-selected'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(id)</span> </span>{\n  <span class=\"hljs-comment\">// ...</span>\n})\n</code></pre><p>其实我们还可以有一些扩展玩法，假设我写了一个<strong>底部按钮</strong>组件<code>footerButton</code>：</p>\n<pre><code><span class=\"xml\">// footer-button.vue\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">footer</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"button\"</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"btnClick\"</span>&gt;</span></span><span class=\"hljs-template-variable\">{{ btnText }}</span><span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">footer</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n    data () {\n        <span class=\"hljs-keyword\">return</span> {\n            <span class=\"hljs-attr\">btnText</span>: <span class=\"hljs-string\">'Button'</span>        \n        }\n    },\n    <span class=\"hljs-attr\">methods</span>: {\n        btnClick() {\n            <span class=\"hljs-comment\">// 点击事件</span>\n        }\n    }\n}\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n</code></pre><p>现在我希望在每个页面都复用这个组件，那在使用<code>Vue-Router</code>的情况下，我的根组件模板结构可能是这样的：</p>\n<pre><code><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">\"main\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">keep-alive</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">router-view</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"content\"</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">router-view</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">keep-alive</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">footer-button</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">footer-button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n<span class=\"hljs-keyword\">import</span> footerButton <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'./components/footer-button.vue'</span>\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> </span></span><span class=\"hljs-template-variable\">{\n    components: {\n        footerButton\n    }</span><span class=\"xml\"><span class=\"undefined\">\n}\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n</code></pre><p>那么我想要的效果是，当<code>router</code>切换到不同组件时，我的底部按钮组件的文本和点击事件都能随之变化，保持其业务相关性。</p>\n<p>可以看到，<code>footerButton</code>组件和<code>router</code>切换的组件是兄弟组件，即非父子组件。那么它们之间的状态及事件联动，就可以用<code>bus</code>来实现，首先声明<code>bus</code>：</p>\n<pre><code><span class=\"hljs-keyword\">window</span>.bus = new Vue({\n    data: {\n        btnText: <span class=\"hljs-string\">''</span>\n    },\n    methods: {\n        setBtnText (text) {\n            this.btnText = text;\n        }\n    }\n});\n</code></pre><p>接下来改造<code>footerButton</code>：</p>\n<pre><code><span class=\"xml\">// footer-button.vue\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">footer</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"button\"</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">\"btnClick\"</span>&gt;</span></span><span class=\"hljs-template-variable\">{{ btnText }}</span><span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">footer</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n    <span class=\"hljs-attr\">computed</span>: {\n        btnText () {\n            <span class=\"hljs-keyword\">return</span> bus.btnText;\n        }\n    },\n    <span class=\"hljs-attr\">methods</span>: {\n        btnClick() {\n            bus.$emit(<span class=\"hljs-string\">'btnClick'</span>);\n        }\n    }\n}\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n</code></pre><p>此时底部按钮的文本已经和<code>bus.btnText</code>绑定在一起，而点击事件则由<code>bus</code>来触发一个名为<code>btnClick</code>的事件。</p>\n<p>既然我们要对每个<code>router</code>切换到的组件做不同处理，那么<code>bus.btnText</code>的修改以及<code>btnClick</code>的监听都应该在<strong>要切换到的组件</strong>中声明，现假设有A、B两个用于切换的组件，以A组件为例：</p>\n<pre><code>// A.vue\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"javascript\">\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> {\n    ...\n    beforeRouteEnter (to, <span class=\"hljs-keyword\">from</span>, next) {\n        bus.setBtnText(<span class=\"hljs-string\">'A Button'</span>);\n        next(<span class=\"hljs-function\"><span class=\"hljs-params\">vm</span> =&gt;</span> {\n            bus.$off(<span class=\"hljs-string\">'btnClick'</span>);\n            bus.$on(<span class=\"hljs-string\">'btnClick'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n                <span class=\"hljs-comment\">// 点击事件</span>\n            })\n        });\n    },\n    ...\n}\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre><p>这里我们在<code>beforeRouteEnter</code>导航钩子中做处理，首先修改了按钮的文本为<code>A Button</code>，随后在<code>next</code>中监听事件，这是因为此钩子中不能直接获取组件实例<code>this</code>，只能在<code>next</code>的回调中通过<code>vm</code>访问。另外在监听事件前用<code>off</code>先移除监听，可以防止重复监听同一事件。</p>\n<p>如果有后端基础（尤其是OOP编程经验）的朋友可能会发现，我们上面做的底部按钮的实现，其实很像OOP中<strong>接口实现多态</strong>的思想。可以这样说，<code>btnClick</code>作为<code>bus</code>接口中的方法，在不同的组件中有不同实现，而<code>footerButton</code>在调用<code>bus</code>的<code>btnClick</code>方法时并不关心具体实现。仔细想来也是颇有意思的事情。</p>\n<h1 id=\"3-\">3. 小结</h1>\n<p>本文简要描述了如何在不使用<code>Vuex</code>的情况下做状态管理，<code>bus</code>作为一个完整的Vue实例，其实是可以做许多事情的，比如我们可以直接在<code>bus</code>中定义计算属性：</p>\n<pre><code>window.bus = <span class=\"hljs-keyword\">new</span> Vue({\n    data: {\n        <span class=\"hljs-keyword\">count</span>: <span class=\"hljs-number\">1</span>\n    },\n    computed: {\n        tenfold () {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.<span class=\"hljs-keyword\">count</span> * <span class=\"hljs-number\">10</span>;\n        }\n    }\n});\n</code></pre><p>然后在其他组件中直接获取<code>bus.tenfold</code>即可，大家可以尽情发挥想象力。</p>\n<p>我们在实现<code>bus</code>的过程中，其实也可以一窥<code>Vuex</code>的许多设计思想，比如<code>Vuex</code> 2.x中各组件也是在计算属性里获取状态，另外也会发现某些与后端思路较像的地方。</p>\n<p>实际上，无论前端还是后端，许多编程思想都是相通的，跟语言无关，希望大家能活学活用。</p>\n<p>全文完。</p>\n<p>转载时请注明 <strong>原作者 A.I.Roland (博客地址：<a href=\"https://airoland.github.io/\">https://airoland.github.io/</a>)</strong> ，并附上 <strong>原文链接</strong> ，谢谢！</p>\n"
}