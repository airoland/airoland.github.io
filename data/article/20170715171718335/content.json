{
    "title": "Docker 快速使用指北",
    "time": "2017/07/15 17:17:18",
    "tags": ["Docker", "Spring Cloud"],
    "content": "[TOC]\n\n# 1 前言\n\n本文主要介绍如何快速上手使用`Docker`和`Docker-compose`（后续会用单独一篇文章来讲解`Docker-swarm`），只做简单演示和讲解，帮助大家把流程走通，更多的命令和参数大家可以自行查找相关资料。\n\n# 2 Docker\n\n## 2.1 Docker安装\n\n如果有旧版本，先卸载掉：\n\n```\n$ sudo yum remove docker \\\n                  docker-common \\\n                  docker-selinux \\\n                  docker-engine\n```\n\n`Docker`目前分为CE和EE两个版本，通常我们使用CE版，先执行以下命令添加`docker-ce`的仓库：\n\n```\n$ sudo yum install -y yum-utils device-mapper-persistent-data lvm2\n$ sudo yum-config-manager \\\n    --add-repo \\\n    https://download.docker.com/linux/centos/docker-ce.repo\n```\n\n然后安装`docker-ce`：\n\n```\nyum makecache fast\nyum -y install docker-ce\n```\n\n启动docker：\n```\nsystemctl restart docker\n```\n\n## 2.2 镜像操作\n\n假设现在已有用Spring Boot生成可用来直接部署的`fat-jar`，名为demo.jar。那么可以编写Dockerfile如下：\n\n```\nFROM openjdk:8                          # 基础镜像\nVOLUME /tmp                             # 将本地文件夹/tmp挂载到当前容器\nADD demo.jar app.jar                    # 将jar添加进镜像并命名为app.jar\nEXPOSE 8080                             # 暴露容器的8080端口\nENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"]   # 容器启动后执行的命令\n```\n\n**注意DockerHub的官方`java`镜像已经deprecated，以后官方jdk会继续在`openjdk`更新，所以我们使用`openjdk:8`镜像作为基础。**\n\ncd进入存放Dockerfile的目录下，用以下命令构建镜像：\n\n```\ndocker build -t airoland/demo .\n```\n\n命令格式说明：\n\n```\ndocker build -t <仓库名称/镜像名称(:标签)> <Dockerfile的相对位置(比如上例中最后的点，表示在当前目录，不要忘了)>\n```\n\n查看所有镜像：\n\n```\ndocker images\n```\n\n删除镜像：\n```\ndocker rmi <镜像ID>\n```\n\n删除所有镜像：\n\n```\ndocker rmi -f $(docker images)\n```\n\n`-f`参数表示强制删除。\n\n## 2.3 容器操作\n\n通过镜像启动容器：\n\n```\ndocker run -d -p 9000:8080 --name demo airoland/demo\n```\n\n- `-d`表示后台执行；\n- `-p 9000:8080`表示通过宿主机的9000端口可以访问容器暴露的8080端口；\n- `--name demo`表示将此容器命名为demo以方便直接通过名字来操作，如果没有指定`--name`则docker会随机分配一个名字；\n- `airoland/demo`是我们上文中生成的镜像。\n\n注意，`docker run`命令在启动镜像时会先查找本地有没有此镜像，如果没有就会去`DockerHub`上下载。\n\n查看在运行的容器：\n\n```\ndocker ps\n```\n\n查看所有容器（包含未运行的）：\n\n```\ndocker ps -a\n```\n\n停止容器：\n\n```\ndocker stop <容器ID或Name>\n```\n\n注意，容器停止后并不会删除，此时无法再用**完全一样的命令**来通过镜像启动容器（即`docker run`），但如果参数有变化，则会通过镜像启动一个新的容器。\n\n若要启动已经停止的容器：\n\n```\ndocker start <容器ID或Name>\n```\n\n删除指定容器：\n\n```\ndocker rm <容器ID或Name>\n```\n\n批量删除容器：\n\n```\ndocker rm $(docker ps -a -q)\n```\n\n注意，`docker rm`命令只会删除已停止的容器，若要强制删除请使用`-f`参数。\n\n比如强制删除所有容器：\n\n```\ndocker rm -f $(docker ps -a -q)\n```\n\n## 2.4 私有仓库\n\n正常情况下使用`docker push`命令会将镜像推送到官方的`DockerHub`上，但有时受网速等因素限制，我们不想把镜像推送到`DockerHub`上，而是希望能有一个私有仓库来供团队内部人员使用。\n\n假设现在有：\n- A（仓库机）\n- B（客户机）\n\n首先在A中下载并运行`registry`镜像，这是一个用于搭建私有Docker仓库的工具。完整的下载并运行命令如下：\n\n```\ndocker run -d -p 5000:5000 --restart=always -v /data/registry:/var/lib/registry --name registry2 registry:2\n```\n\n说明：\n- `--restart=always`表示容器始终自动重启；\n- `-v /data/registry:/var/lib/registry`表示将宿主机的`/data/registry`挂载到容器的`/var/lib/registry`，**因为如果不挂载宿主机目录的话，私有仓库中的所有镜像会在此容器被删除后一同消失。**另外需要注意，`registry2`与`registry1`不同，`registry2`容器内镜像存储位置为`/var/lib/registry`，而网上许多资料挂载的是`registry1`的镜像存储目录`/tmp/registry`。\n\n接下来先为想要push的镜像打tag，否则是push不到私有仓库的：\n\n```\ndocker tag <镜像name或id> <A的IP或HostName:5000/镜像name>\n```\n\n比如：\n\n```\ndocker tag eb96ca1402aa localhost:5000/airloand/demo\n```\n\n然后push：\n\n```\ndocker push localhost:5000/airoland/demo\n```\n\n不过后来我发现了一个更简单的方法，在build的时候就直接打包成**私有仓库格式的名字**，然后不需要打tag，直接push即可：\n\n```\ndocker build -t localhost:5000/airloand/demo .\ndocker push localhost:5000/airloand/demo\n```\n\n查看私有仓库中已有的镜像：\n\n```\ncurl <A的IP或HostName:5000>/v2/_catalog\n```\n\n如果要在A拉取私有仓库的镜像，直接使用如下命令即可：\n\n```\ndocker pull localhost:5000/你的镜像\n```\n\n但如果要**在B中拉取A的镜像**，Docker会要求使用`https`来传输，我们需要修改**B**中Docker的配置文件来使其允许`http`协议。\n\n由于`CentOS 7`和`CentOS 6`中Docker配置文件的存储路径、文件内容和修改方式是不一致的，而网上大部分是`CentOS 6`的修改方法，很容易找到，因此本文我主要介绍一下`CentOS 7`中的修改方法：\n\n`CentOS 7`中Docker配置文件的路径为：`/usr/lib/systemd/system/docker.service`\n\n修改**B主机**的`docker.service`文件中的`ExecStart=/usr/bin/dockerd`属性，修改为：\n\n```\nExecStart=/usr/bin/dockerd --insecure-registry <A的IP:5000>\n```\n\n然后重启docker：\n```\nsystemctl daemon-reload\nsystemctl restart docker\n```\n\n此时就可以在B中拉取A的镜像了：\n\n```\ndocker pull <A的IP:5000>/你的镜像\n```\n\n直接写A的IP即可，前面不要加http://\n\n# 3 Docker-Compose\n\n## 3.1 安装\n\n在`CentOS`上用以下命令安装：\n```\ncurl -L https://github.com/docker/compose/releases/download/<DockerCompose版本>/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose\n```\n\n- `uname -s`表示系统名，在`CentOS`中显示为`Linux`；\n- `uname -m`表示系统位数x86_64；\n- `<DockerCompose版本>`表示你要下载的docker-compose版本，截止本文写完最新稳定版为`1.15.0`；\n- ` > /usr/local/bin/docker-compose`表示将文件保存为`/usr/local/bin/`目录下的`docker-compose`文件。\n\n这条命令的本质其实是下载`GitHub`上的某版本的`docker-compose-Linux-x86_64`文件，然后重命名为`/usr/local/bin/docker-compose`，因此如果下载过慢的话，可以直接去`GitHub`网站的[DockerCompose](https://github.com/docker/compose/releases)仓库下载你想要版本的`docker-compose-Linux-x86_64`文件，然后放在服务器的`/usr/local/bin/`下，改名`docker-compose`就可以了。\n\n安装docker-compose命令补全工具：\n\n```\ncurl -L https://raw.githubusercontent.com/docker/compose/<DockerCompose版本>/contrib/completion/bash/docker-compose -o /etc/bash_completion.d/docker-compose\n```\n\n## 3.2 Spring Cloud示例\n\n下面我们将利用Spring Cloud来展示如何配置Docker Compose。\n\n首先准备多个Spring Cloud镜像，比如最简单的`eureka`、`provider`、`consumer`三个微服务镜像，然后基本功能为`consumer`和`provider`注册到`eureka`上，然后`consumer`通过feign来调用`provider`。\n\n通常当这三个微服务都在同一台主机上时，`consumer`和`provider`的Eureka注册地址配置如下：\n\n```\neureka:\n  client:\n    serviceUrl:\n      defaultZone: http://localhost:8379/eureka/\n```\n\n但由于docker网络默认是bridge模式，因此各容器的localhost都不相同，我们需要把`consumer`和`provider`的Eureka注册地址配置改为另一个主机名（比如`discovery`）：\n\n```\neureka:\n  client:\n    serviceUrl:\n      defaultZone: http://discovery:8379/eureka/\n```\n\n此时我们可以编写`docker-compose.yml`：\n\n```\nversion: '2.1'              # 表示该docker-compose.yml文件使用的是Version 2.1 file format\n\nservices:\n  eureka:                   # 指定服务名称\n    image: airoland/eureka\n    ports:\n      - 8379:8379\n  consumer:\n    image: airoland/consumer\n    ports:\n      - 8080:8080           # 暴露8080端口用于测试\n    links:\n      - eureka:discovery    # 链接到eureka，格式为SERVICE:ALIAS，即把eureka指定为discovery别名\n  provider:\n    image: airoland/provider\n    links:\n      - eureka:discovery\n```\n\n此时微服务容器是link到eureka容器上的，它们可以通过别名`discovery`当作主机名来进行服务注册。\n\n另外，在`Version 2.x file format`的docker-compose.yml中，同一个项目的所有服务共享一个公共的隔离网络，**服务可以使用暴露的端口和服务名称作为主机名来发现其他服务**，因此，docker-compose.yml也可以写成如下形式：\n\n```\nversion: '2.1'              # 表示该docker-compose.yml文件使用的是Version 2.1 file format\n\nservices:\n  discovery:                # 直接指定服务名称为discovery，就可以省略links了\n    image: airoland/eureka\n    ports:\n      - 8379:8379\n  consumer:\n    image: airoland/consumer\n    ports:\n      - 8080:8080\n  provider:\n    image: airoland/provider\n```\n\n然后在`docker-compose.yml`的目录下执行：\n\n```\ndocker-compose up\n```\n\n此时会看到所有容器日志的聚合输出。\n\n也可以后台启动：\n\n```\ndocker-compose up -d\n```\n\n## 3.3 高可用Eureka Server编排示例\n\n假设有两个Eureka Server微服务`eureka1`和`eureka2`，现在我们要做HA，首先将`eureka1`的注册地址写成：\n\n```\neureka:\n  client:\n    serviceUrl:\n      defaultZone: http://peer2:8380/eureka/\n```\n\n同理`eureka2`的注册地址写成：\n\n```\neureka:\n  client:\n    serviceUrl:\n      defaultZone: http://peer1:8379/eureka/\n```\n\n理论上讲，我们的`docker-compose.yml`可以这样编写：\n\n```\nversion: \"2.1\"\n\nservices:\n  eureka1:\n    hostname: peer1     # 指定hostname\n    image: eureka1\n    links:\n    - eureka2:peer2\n    ports:\n    - \"8379:8379\"\n  eureka2:\n    hostname: peer2\n    image: eureka2\n    links:\n    - eureka1:peer1\n    ports:\n    - \"8380:8380\"\n```\n\n但假如像这样通过`links`的方式来连接，当执行`docker-compose up`命令启动时，就会报循环依赖的错误：\n\n``` \nERROR: Circular dependency between eureka1 and eureka2\n```\n\n而从上节中我们得知，服务之间可以直接通过服务名来连接，因此简单的解决方案如下：\n\n```\nversion: \"2.1\"\n\nservices:\n  peer1:\n    image: eureka1\n    ports:\n    - \"8379:8379\"\n  peer2:\n    image: eureka2\n    ports:\n    - \"8380:8380\"\n```\n\n此时再用`docker-compose up`启动，稍等片刻就可以分别访问这两个Eureka的界面来查看HA状态了。\n\n全文完。\n\n转载时请注明 **原作者 A.I.Roland (博客地址：https://airoland.github.io/)** ，并附上 **原文链接** ，谢谢！",
    "abstract": "本文主要介绍如何快速上手使用Docker和Docker-compose（后续会用单独一篇文章来讲解Docker-swarm），只做简单演示和讲解，帮助大家把流程走通，更多的命令和参数大家可以自行查找相关资料。Docker目前分为CE和EE两个版本，通常我们使用CE版...",
    "html": "<ul><li><a href=\"javascript:document.getElementById('1-').scrollIntoView()\">1 前言</a></li>\n<li><a href=\"javascript:document.getElementById('2-docker').scrollIntoView()\">2 Docker</a>\n<ul><li><a href=\"javascript:document.getElementById('2-1-docker-').scrollIntoView()\">2.1 Docker安装</a></li>\n<li><a href=\"javascript:document.getElementById('2-2-').scrollIntoView()\">2.2 镜像操作</a></li>\n<li><a href=\"javascript:document.getElementById('2-3-').scrollIntoView()\">2.3 容器操作</a></li>\n<li><a href=\"javascript:document.getElementById('2-4-').scrollIntoView()\">2.4 私有仓库</a>\n</li>\n</ul>\n</li><li><a href=\"javascript:document.getElementById('3-docker-compose').scrollIntoView()\">3 Docker-Compose</a>\n<ul><li><a href=\"javascript:document.getElementById('3-1-').scrollIntoView()\">3.1 安装</a></li>\n<li><a href=\"javascript:document.getElementById('3-2-spring-cloud-').scrollIntoView()\">3.2 Spring Cloud示例</a></li>\n<li><a href=\"javascript:document.getElementById('3-3-eureka-server-').scrollIntoView()\">3.3 高可用Eureka Server编排示例</a></li>\n</ul></li>\n</ul>\n\n<h1 id=\"1-\">1 前言</h1>\n<p>本文主要介绍如何快速上手使用<code>Docker</code>和<code>Docker-compose</code>（后续会用单独一篇文章来讲解<code>Docker-swarm</code>），只做简单演示和讲解，帮助大家把流程走通，更多的命令和参数大家可以自行查找相关资料。</p>\n<h1 id=\"2-docker\">2 Docker</h1>\n<h2 id=\"2-1-docker-\">2.1 Docker安装</h2>\n<p>如果有旧版本，先卸载掉：</p>\n<pre><code>$ sudo yum remove docker <span class=\"hljs-string\">\\</span>\n                  docker-common <span class=\"hljs-string\">\\</span>\n                  docker-selinux <span class=\"hljs-string\">\\</span>\n                  docker-engine\n</code></pre><p><code>Docker</code>目前分为CE和EE两个版本，通常我们使用CE版，先执行以下命令添加<code>docker-ce</code>的仓库：</p>\n<pre><code><span class=\"hljs-variable\">$ </span>sudo yum install -y yum-utils device-mapper-persistent-data lvm2\n<span class=\"hljs-variable\">$ </span>sudo yum-config-manager \\\n    --add-repo \\\n    <span class=\"hljs-symbol\">https:</span>/<span class=\"hljs-regexp\">/download.docker.com/linux</span><span class=\"hljs-regexp\">/centos/docker</span>-ce.repo\n</code></pre><p>然后安装<code>docker-ce</code>：</p>\n<pre><code>yum makecache fast\nyum -y <span class=\"hljs-keyword\">install</span> docker-ce\n</code></pre><p>启动docker：</p>\n<pre><code><span class=\"hljs-attribute\">systemctl restart docker</span>\n</code></pre><h2 id=\"2-2-\">2.2 镜像操作</h2>\n<p>假设现在已有用Spring Boot生成可用来直接部署的<code>fat-jar</code>，名为demo.jar。那么可以编写Dockerfile如下：</p>\n<pre><code><span class=\"hljs-keyword\">FROM</span> openjdk:<span class=\"hljs-number\">8</span>                          <span class=\"hljs-comment\"># 基础镜像</span>\n<span class=\"hljs-keyword\">VOLUME</span><span class=\"bash\"> /tmp                             <span class=\"hljs-comment\"># 将本地文件夹/tmp挂载到当前容器</span>\n</span><span class=\"hljs-keyword\">ADD</span><span class=\"bash\"> demo.jar app.jar                    <span class=\"hljs-comment\"># 将jar添加进镜像并命名为app.jar</span>\n</span><span class=\"hljs-keyword\">EXPOSE</span> <span class=\"hljs-number\">8080</span>                             <span class=\"hljs-comment\"># 暴露容器的8080端口</span>\n<span class=\"hljs-keyword\">ENTRYPOINT</span><span class=\"bash\"> [<span class=\"hljs-string\">\"java\"</span>,<span class=\"hljs-string\">\"-jar\"</span>,<span class=\"hljs-string\">\"/app.jar\"</span>]   <span class=\"hljs-comment\"># 容器启动后执行的命令</span></span>\n</code></pre><p><strong>注意DockerHub的官方<code>java</code>镜像已经deprecated，以后官方jdk会继续在<code>openjdk</code>更新，所以我们使用<code>openjdk:8</code>镜像作为基础。</strong></p>\n<p>cd进入存放Dockerfile的目录下，用以下命令构建镜像：</p>\n<pre><code><span class=\"hljs-symbol\">docker</span> <span class=\"hljs-keyword\">build </span>-t airoland/demo .\n</code></pre><p>命令格式说明：</p>\n<pre><code>docker build -t <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">仓库名称</span>/镜像名称(<span class=\"hljs-attr\">:</span>标签)&gt;</span> <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">Dockerfile的相对位置(比如上例中最后的点，表示在当前目录，不要忘了)</span>&gt;</span>\n</code></pre><p>查看所有镜像：</p>\n<pre><code><span class=\"hljs-attribute\">docker images</span>\n</code></pre><p>删除镜像：</p>\n<pre><code>docker rmi <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">镜像ID</span>&gt;</span>\n</code></pre><p>删除所有镜像：</p>\n<pre><code>docker rmi <span class=\"hljs-_\">-f</span> $(docker images)\n</code></pre><p><code>-f</code>参数表示强制删除。</p>\n<h2 id=\"2-3-\">2.3 容器操作</h2>\n<p>通过镜像启动容器：</p>\n<pre><code>docker <span class=\"hljs-keyword\">run</span><span class=\"bash\"> <span class=\"hljs-_\">-d</span> -p 9000:8080 --name demo airoland/demo</span>\n</code></pre><ul>\n<li><code>-d</code>表示后台执行；</li>\n<li><code>-p 9000:8080</code>表示通过宿主机的9000端口可以访问容器暴露的8080端口；</li>\n<li><code>--name demo</code>表示将此容器命名为demo以方便直接通过名字来操作，如果没有指定<code>--name</code>则docker会随机分配一个名字；</li>\n<li><code>airoland/demo</code>是我们上文中生成的镜像。</li>\n</ul>\n<p>注意，<code>docker run</code>命令在启动镜像时会先查找本地有没有此镜像，如果没有就会去<code>DockerHub</code>上下载。</p>\n<p>查看在运行的容器：</p>\n<pre><code><span class=\"hljs-attribute\">docker ps</span>\n</code></pre><p>查看所有容器（包含未运行的）：</p>\n<pre><code>docker ps <span class=\"hljs-_\">-a</span>\n</code></pre><p>停止容器：</p>\n<pre><code>docker <span class=\"hljs-keyword\">stop</span> &lt;容器<span class=\"hljs-keyword\">ID</span>或<span class=\"hljs-keyword\">Name</span>&gt;\n</code></pre><p>注意，容器停止后并不会删除，此时无法再用<strong>完全一样的命令</strong>来通过镜像启动容器（即<code>docker run</code>），但如果参数有变化，则会通过镜像启动一个新的容器。</p>\n<p>若要启动已经停止的容器：</p>\n<pre><code>docker <span class=\"hljs-keyword\">start</span> &lt;容器<span class=\"hljs-keyword\">ID</span>或<span class=\"hljs-keyword\">Name</span>&gt;\n</code></pre><p>删除指定容器：</p>\n<pre><code>docker rm <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">容器ID或Name</span>&gt;</span>\n</code></pre><p>批量删除容器：</p>\n<pre><code>docker rm $<span class=\"hljs-comment\">(docker ps -a -q)</span>\n</code></pre><p>注意，<code>docker rm</code>命令只会删除已停止的容器，若要强制删除请使用<code>-f</code>参数。</p>\n<p>比如强制删除所有容器：</p>\n<pre><code>docker rm <span class=\"hljs-_\">-f</span> $(docker ps <span class=\"hljs-_\">-a</span> -q)\n</code></pre><h2 id=\"2-4-\">2.4 私有仓库</h2>\n<p>正常情况下使用<code>docker push</code>命令会将镜像推送到官方的<code>DockerHub</code>上，但有时受网速等因素限制，我们不想把镜像推送到<code>DockerHub</code>上，而是希望能有一个私有仓库来供团队内部人员使用。</p>\n<p>假设现在有：</p>\n<ul>\n<li>A（仓库机）</li>\n<li>B（客户机）</li>\n</ul>\n<p>首先在A中下载并运行<code>registry</code>镜像，这是一个用于搭建私有Docker仓库的工具。完整的下载并运行命令如下：</p>\n<pre><code>docker run -d -p <span class=\"hljs-number\">5000</span>:<span class=\"hljs-number\">5000</span> --restart=always -v /data/<span class=\"hljs-symbol\">registry:</span>/var/<span class=\"hljs-class\"><span class=\"hljs-keyword\">lib</span>/<span class=\"hljs-title\">registry</span> --<span class=\"hljs-title\">name</span> <span class=\"hljs-title\">registry2</span> <span class=\"hljs-title\">registry</span>:2</span>\n</code></pre><p>说明：</p>\n<ul>\n<li><code>--restart=always</code>表示容器始终自动重启；</li>\n<li><code>-v /data/registry:/var/lib/registry</code>表示将宿主机的<code>/data/registry</code>挂载到容器的<code>/var/lib/registry</code>，<strong>因为如果不挂载宿主机目录的话，私有仓库中的所有镜像会在此容器被删除后一同消失。</strong>另外需要注意，<code>registry2</code>与<code>registry1</code>不同，<code>registry2</code>容器内镜像存储位置为<code>/var/lib/registry</code>，而网上许多资料挂载的是<code>registry1</code>的镜像存储目录<code>/tmp/registry</code>。</li>\n</ul>\n<p>接下来先为想要push的镜像打tag，否则是push不到私有仓库的：</p>\n<pre><code>docker tag &lt;镜像<span class=\"hljs-built_in\">name</span>或<span class=\"hljs-built_in\">id</span>&gt; &lt;A的IP或HostName:<span class=\"hljs-number\">5000</span>/镜像<span class=\"hljs-built_in\">name</span>&gt;\n</code></pre><p>比如：</p>\n<pre><code>docker <span class=\"hljs-keyword\">tag</span> <span class=\"hljs-title\">eb96ca1402aa</span> localhost:<span class=\"hljs-number\">5000</span>/airloand/demo\n</code></pre><p>然后push：</p>\n<pre><code>docker <span class=\"hljs-keyword\">push</span> localhost:<span class=\"hljs-number\">5000</span><span class=\"hljs-regexp\">/airoland/</span>demo\n</code></pre><p>不过后来我发现了一个更简单的方法，在build的时候就直接打包成<strong>私有仓库格式的名字</strong>，然后不需要打tag，直接push即可：</p>\n<pre><code>docker build -t <span class=\"hljs-string\">localhost:</span><span class=\"hljs-number\">5000</span><span class=\"hljs-regexp\">/airloand/</span>demo .\ndocker push <span class=\"hljs-string\">localhost:</span><span class=\"hljs-number\">5000</span><span class=\"hljs-regexp\">/airloand/</span>demo\n</code></pre><p>查看私有仓库中已有的镜像：</p>\n<pre><code><span class=\"hljs-symbol\">curl</span> &lt;A的<span class=\"hljs-built_in\">IP</span>或HostName:<span class=\"hljs-number\">5000</span>&gt;/<span class=\"hljs-built_in\">v2</span>/_catalog\n</code></pre><p>如果要在A拉取私有仓库的镜像，直接使用如下命令即可：</p>\n<pre><code>docker pull <span class=\"hljs-string\">localhost:</span><span class=\"hljs-number\">5000</span>/你的镜像\n</code></pre><p>但如果要<strong>在B中拉取A的镜像</strong>，Docker会要求使用<code>https</code>来传输，我们需要修改<strong>B</strong>中Docker的配置文件来使其允许<code>http</code>协议。</p>\n<p>由于<code>CentOS 7</code>和<code>CentOS 6</code>中Docker配置文件的存储路径、文件内容和修改方式是不一致的，而网上大部分是<code>CentOS 6</code>的修改方法，很容易找到，因此本文我主要介绍一下<code>CentOS 7</code>中的修改方法：</p>\n<p><code>CentOS 7</code>中Docker配置文件的路径为：<code>/usr/lib/systemd/system/docker.service</code></p>\n<p>修改<strong>B主机</strong>的<code>docker.service</code>文件中的<code>ExecStart=/usr/bin/dockerd</code>属性，修改为：</p>\n<pre><code>ExecStart=/usr/bin/dockerd <span class=\"hljs-comment\">--insecure-registry &lt;A的IP:5000&gt;</span>\n</code></pre><p>然后重启docker：</p>\n<pre><code><span class=\"hljs-attribute\">systemctl daemon-reload\nsystemctl restart docker</span>\n</code></pre><p>此时就可以在B中拉取A的镜像了：</p>\n<pre><code><span class=\"hljs-symbol\">docker</span> pull &lt;A的<span class=\"hljs-built_in\">IP</span>:<span class=\"hljs-number\">5000</span>&gt;/你的镜像\n</code></pre><p>直接写A的IP即可，前面不要加http://</p>\n<h1 id=\"3-docker-compose\">3 Docker-Compose</h1>\n<h2 id=\"3-1-\">3.1 安装</h2>\n<p>在<code>CentOS</code>上用以下命令安装：</p>\n<pre><code>curl -L https:<span class=\"hljs-regexp\">//gi</span>thub.com<span class=\"hljs-regexp\">/docker/</span>compose<span class=\"hljs-regexp\">/releases/</span>download<span class=\"hljs-regexp\">/&lt;DockerCompose版本&gt;/</span>docker-compose-`uname -s`-`uname -m` &gt; <span class=\"hljs-regexp\">/usr/</span>local<span class=\"hljs-regexp\">/bin/</span>docker-compose\n</code></pre><ul>\n<li><code>uname -s</code>表示系统名，在<code>CentOS</code>中显示为<code>Linux</code>；</li>\n<li><code>uname -m</code>表示系统位数x86_64；</li>\n<li><code>&lt;DockerCompose版本&gt;</code>表示你要下载的docker-compose版本，截止本文写完最新稳定版为<code>1.15.0</code>；</li>\n<li><code>&gt; /usr/local/bin/docker-compose</code>表示将文件保存为<code>/usr/local/bin/</code>目录下的<code>docker-compose</code>文件。</li>\n</ul>\n<p>这条命令的本质其实是下载<code>GitHub</code>上的某版本的<code>docker-compose-Linux-x86_64</code>文件，然后重命名为<code>/usr/local/bin/docker-compose</code>，因此如果下载过慢的话，可以直接去<code>GitHub</code>网站的<a href=\"https://github.com/docker/compose/releases\">DockerCompose</a>仓库下载你想要版本的<code>docker-compose-Linux-x86_64</code>文件，然后放在服务器的<code>/usr/local/bin/</code>下，改名<code>docker-compose</code>就可以了。</p>\n<p>安装docker-compose命令补全工具：</p>\n<pre><code>curl -L https:<span class=\"hljs-regexp\">//</span>raw.githubusercontent.com<span class=\"hljs-regexp\">/docker/</span>compose<span class=\"hljs-regexp\">/&lt;DockerCompose版本&gt;/</span>contrib<span class=\"hljs-regexp\">/completion/</span>bash<span class=\"hljs-regexp\">/docker-compose -o /</span>etc<span class=\"hljs-regexp\">/bash_completion.d/</span>docker-compose\n</code></pre><h2 id=\"3-2-spring-cloud-\">3.2 Spring Cloud示例</h2>\n<p>下面我们将利用Spring Cloud来展示如何配置Docker Compose。</p>\n<p>首先准备多个Spring Cloud镜像，比如最简单的<code>eureka</code>、<code>provider</code>、<code>consumer</code>三个微服务镜像，然后基本功能为<code>consumer</code>和<code>provider</code>注册到<code>eureka</code>上，然后<code>consumer</code>通过feign来调用<code>provider</code>。</p>\n<p>通常当这三个微服务都在同一台主机上时，<code>consumer</code>和<code>provider</code>的Eureka注册地址配置如下：</p>\n<pre><code><span class=\"hljs-attribute\">eureka</span>:\n  <span class=\"hljs-attribute\">client</span>:\n    <span class=\"hljs-attribute\">serviceUrl</span>:\n      <span class=\"hljs-attribute\">defaultZone</span>: <span class=\"hljs-attribute\">http</span>:<span class=\"hljs-comment\">//localhost:8379/eureka/</span>\n</code></pre><p>但由于docker网络默认是bridge模式，因此各容器的localhost都不相同，我们需要把<code>consumer</code>和<code>provider</code>的Eureka注册地址配置改为另一个主机名（比如<code>discovery</code>）：</p>\n<pre><code><span class=\"hljs-attribute\">eureka</span>:\n  <span class=\"hljs-attribute\">client</span>:\n    <span class=\"hljs-attribute\">serviceUrl</span>:\n      <span class=\"hljs-attribute\">defaultZone</span>: <span class=\"hljs-attribute\">http</span>:<span class=\"hljs-comment\">//discovery:8379/eureka/</span>\n</code></pre><p>此时我们可以编写<code>docker-compose.yml</code>：</p>\n<pre><code><span class=\"hljs-attribute\">version</span>: '2.1'              # 表示该docker-compose.yml文件使用的是Version 2.1 file format\n\n<span class=\"yaml\"><span class=\"hljs-attr\">services:</span>\n<span class=\"hljs-attr\">  eureka:</span>                   <span class=\"hljs-comment\"># 指定服务名称</span>\n<span class=\"hljs-attr\">    image:</span> <span class=\"hljs-string\">airoland/eureka</span>\n<span class=\"hljs-attr\">    ports:</span>\n<span class=\"hljs-bullet\">      -</span> <span class=\"hljs-number\">8379</span><span class=\"hljs-string\">:8379</span>\n<span class=\"hljs-attr\">  consumer:</span>\n<span class=\"hljs-attr\">    image:</span> <span class=\"hljs-string\">airoland/consumer</span>\n<span class=\"hljs-attr\">    ports:</span>\n<span class=\"hljs-bullet\">      -</span> <span class=\"hljs-number\">8080</span><span class=\"hljs-string\">:8080</span>           <span class=\"hljs-comment\"># 暴露8080端口用于测试</span>\n<span class=\"hljs-attr\">    links:</span>\n<span class=\"hljs-attr\">      - eureka:</span><span class=\"hljs-string\">discovery</span>    <span class=\"hljs-comment\"># 链接到eureka，格式为SERVICE:ALIAS，即把eureka指定为discovery别名</span>\n<span class=\"hljs-attr\">  provider:</span>\n<span class=\"hljs-attr\">    image:</span> <span class=\"hljs-string\">airoland/provider</span>\n<span class=\"hljs-attr\">    links:</span>\n<span class=\"hljs-attr\">      - eureka:</span><span class=\"hljs-string\">discovery</span></span>\n</code></pre><p>此时微服务容器是link到eureka容器上的，它们可以通过别名<code>discovery</code>当作主机名来进行服务注册。</p>\n<p>另外，在<code>Version 2.x file format</code>的docker-compose.yml中，同一个项目的所有服务共享一个公共的隔离网络，<strong>服务可以使用暴露的端口和服务名称作为主机名来发现其他服务</strong>，因此，docker-compose.yml也可以写成如下形式：</p>\n<pre><code><span class=\"hljs-attribute\">version</span>: '2.1'              # 表示该docker-compose.yml文件使用的是Version 2.1 file format\n\n<span class=\"dts\"><span class=\"hljs-symbol\">services:</span>\n<span class=\"hljs-symbol\">  discovery:</span>                <span class=\"hljs-meta\"># 直接指定服务名称为discovery，就可以省略links了</span>\n<span class=\"hljs-symbol\">    image:</span> airoland/eureka\n<span class=\"hljs-symbol\">    ports:</span>\n      - <span class=\"hljs-number\">8379</span>:<span class=\"hljs-number\">8379</span>\n<span class=\"hljs-symbol\">  consumer:</span>\n<span class=\"hljs-symbol\">    image:</span> airoland/consumer\n<span class=\"hljs-symbol\">    ports:</span>\n      - <span class=\"hljs-number\">8080</span>:<span class=\"hljs-number\">8080</span>\n<span class=\"hljs-symbol\">  provider:</span>\n<span class=\"hljs-symbol\">    image:</span> airoland/provider</span>\n</code></pre><p>然后在<code>docker-compose.yml</code>的目录下执行：</p>\n<pre><code><span class=\"hljs-attribute\">docker-compose up</span>\n</code></pre><p>此时会看到所有容器日志的聚合输出。</p>\n<p>也可以后台启动：</p>\n<pre><code>docker-compose up <span class=\"hljs-_\">-d</span>\n</code></pre><h2 id=\"3-3-eureka-server-\">3.3 高可用Eureka Server编排示例</h2>\n<p>假设有两个Eureka Server微服务<code>eureka1</code>和<code>eureka2</code>，现在我们要做HA，首先将<code>eureka1</code>的注册地址写成：</p>\n<pre><code><span class=\"hljs-attribute\">eureka</span>:\n  <span class=\"hljs-attribute\">client</span>:\n    <span class=\"hljs-attribute\">serviceUrl</span>:\n      <span class=\"hljs-attribute\">defaultZone</span>: <span class=\"hljs-attribute\">http</span>:<span class=\"hljs-comment\">//peer2:8380/eureka/</span>\n</code></pre><p>同理<code>eureka2</code>的注册地址写成：</p>\n<pre><code><span class=\"hljs-attribute\">eureka</span>:\n  <span class=\"hljs-attribute\">client</span>:\n    <span class=\"hljs-attribute\">serviceUrl</span>:\n      <span class=\"hljs-attribute\">defaultZone</span>: <span class=\"hljs-attribute\">http</span>:<span class=\"hljs-comment\">//peer1:8379/eureka/</span>\n</code></pre><p>理论上讲，我们的<code>docker-compose.yml</code>可以这样编写：</p>\n<pre><code><span class=\"hljs-attribute\">version</span>: \"2.1\"\n\n<span class=\"less\"><span class=\"hljs-attribute\">services</span>:\n  <span class=\"hljs-attribute\">eureka1</span>:\n    <span class=\"hljs-attribute\">hostname</span>: peer1     # 指定hostname\n    <span class=\"hljs-attribute\">image</span>: eureka1\n    <span class=\"hljs-attribute\">links</span>:\n    - <span class=\"hljs-attribute\">eureka2</span>:peer2\n    <span class=\"hljs-attribute\">ports</span>:\n    - <span class=\"hljs-string\">\"8379:8379\"</span>\n  <span class=\"hljs-attribute\">eureka2</span>:\n    <span class=\"hljs-attribute\">hostname</span>: peer2\n    <span class=\"hljs-attribute\">image</span>: eureka2\n    <span class=\"hljs-attribute\">links</span>:\n    - <span class=\"hljs-attribute\">eureka1</span>:peer1\n    <span class=\"hljs-attribute\">ports</span>:\n    - <span class=\"hljs-string\">\"8380:8380\"</span></span>\n</code></pre><p>但假如像这样通过<code>links</code>的方式来连接，当执行<code>docker-compose up</code>命令启动时，就会报循环依赖的错误：</p>\n<pre><code><span class=\"hljs-keyword\">ERROR: </span>Circular dependency between eureka1 and eureka2\n</code></pre><p>而从上节中我们得知，服务之间可以直接通过服务名来连接，因此简单的解决方案如下：</p>\n<pre><code><span class=\"hljs-symbol\">version:</span> <span class=\"hljs-string\">\"2.1\"</span>\n<span class=\"hljs-symbol\">\nservices:</span>\n<span class=\"hljs-symbol\">  peer1:</span>\n<span class=\"hljs-symbol\">    image:</span> eureka1\n<span class=\"hljs-symbol\">    ports:</span>\n    - <span class=\"hljs-string\">\"8379:8379\"</span>\n<span class=\"hljs-symbol\">  peer2:</span>\n<span class=\"hljs-symbol\">    image:</span> eureka2\n<span class=\"hljs-symbol\">    ports:</span>\n    - <span class=\"hljs-string\">\"8380:8380\"</span>\n</code></pre><p>此时再用<code>docker-compose up</code>启动，稍等片刻就可以分别访问这两个Eureka的界面来查看HA状态了。</p>\n<p>全文完。</p>\n<p>转载时请注明 <strong>原作者 A.I.Roland (博客地址：<a href=\"https://airoland.github.io/\">https://airoland.github.io/</a>)</strong> ，并附上 <strong>原文链接</strong> ，谢谢！</p>\n"
}