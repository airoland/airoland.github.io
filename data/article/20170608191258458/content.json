{
    "title": "Spring Cloud Stream 使用指北",
    "time": "2017/06/08 19:12:40",
    "tags": ["Spring Cloud"],
    "content": "[TOC]\n\n# 1. 概述\n\n``Spring Cloud Stream``（以下简称SCS）是一个用于构建消息驱动微服务的框架。简单来说，通过SCS我们可以快速地在微服务之间传递异步消息，这对于一些刚起步时需求简单的消息应用是很方便的。~~感谢Spring团队又喂了我们一个大块语法糖~~（笑）。\n\n# 2. 入门\n\n尽管很方便，但必要的准备工作还是要做的。\n\nSCS本身并不提供消息服务器，因此我们还是要安装像``RabbitMQ``或``Kafka``这样的消息服务器，本文会使用``RabbitMQ``来做讲解，具体如何安装``Erlang``和``RabbitMQ``这里不再赘述。**安装好以后可以暂时不对``RabbitMQ``做配置。**但要记得运行``rabbitmq-plugins enable rabbitmq_management``来激活管理平台以方便后续使用（默认地址 localhost:15672，用户名密码都是guest）。\n\n随后在需要使用SCS的微服务中引入jar包：\n\n```\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-stream-rabbit</artifactId>\n</dependency>\n```\n\n被``Spring Boot``的``AutoConfiguration``洗礼过的朋友应该知道，以``Spring``团队一贯的尿性，只要安装好环境引入jar包后，无需做任何多余配置微服务就应该可以跟``RabbitMQ``直接连上，而事实也的确如此。\n\n那我们就先不管``RabbitMQ``，直接开始编写微服务吧！\n\n## 2.1 生产者\n\n1.创建一个``sc-stream-producer``微服务，默认端口8080；\n\n2.创建一个接口作为通道，举例：\n\n```\n@Component\npublic interface MyChannel {\n\t\n\tString OUTPUT = \"test\";\n\t\n    @Output(OUTPUT)\n    MessageChannel output();\n\n}\n```\n\n``@Output``注解代表这是一个输出通道，而通道名就是我们定义的``test``，**一个接口中可以定义多个输入和输出通道**。\n\n实际上SCS本身提供了三个预定义接口通道，即``Source.class``单向输出通道，``Sink.class``单向输入通道，以及继承了它们两个的``Processor.class``，你可以在源码``org.springframework.cloud.stream.messaging``包中找到它们。但它们都只是简单示例，真正开发时我们肯定还是要自定义接口作为通道；\n\n3.创建用于发送消息的接口（或直接在启动类中编写）：\n\n```\n@RestController\npublic class SendController {\n\n    @Autowired\n    private MyChannel sender;\n    \n    @RequestMapping(\"/send\")\n    public String send(){\n        try {\n            sender.output().send(MessageBuilder.withPayload(\"Hello World\").build());\n            return \"success\";\n        } catch (Exception e) {\n            e.printStackTrace();\n            return \"fail\";\n        }\n    }\n    \n}\n```\n\n当然，你也可以使用``Spring Boot Test``直接测试：\n\n```\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class ScStreamProducerApplicationTests {\n\t\n    @Autowired\n    private MyChannel sender;\n    \n    @Test\n    public void send() throws Exception {\n        sender.output().send(MessageBuilder.withPayload(\"Hello World\").build());\n    }\n    \n}\n\n```\n\n注：``MessageBuilder``使用``org.springframework.integration.support.MessageBuilder``或``org.springframework.messaging.support.MessageBuilder``都可以，本身前者就是对后者的整合，Payload则是消息实体；\n\n\n4.在启动类上添加``@EnableBinding``注解：\n\n```\n@SpringBootApplication\n@EnableBinding(MyChannel.class)\npublic class ScStreamProducerApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(ScStreamProducerApplication.class, args);\n\t}\n\t\n}\n```\n\n需要注意的是，``@EnableBinding``注解是必须要加的（即使你只使用``JUnit``测试），**但并不是必须添加在启动类上**，其实你可以把它放在任何一个``Spring``能够扫描到的类。但为了方便查找，还是**推荐放在启动类或者消息类上**。\n\n生产者至此告一段落，接下来我们看一下消费者。\n\n## 2.2 消费者\n\n1.创建一个``sc-stream-consumer``微服务，为防止与生产者冲突，端口号设为8081；\n\n2.和生产者一样，创建一个接口作为通道，举例：\n\n```\n@Component\npublic interface MyChannel {\n\t\n    String INPUT = \"test\";\n\t\n    @Input(INPUT)\n    SubscribableChannel input();\n\n}\n```\n\n``@Input``注解代表这是一个输入通道，**通道名需要与生产者对应才能接收消息**，因此我们也定义为``test``；\n\n3.创建用于接收消息的类（或直接在启动类中编写）：\n\n```\n@Component\npublic class Receiver {\n\t\n\t@StreamListener(MyChannel.INPUT)\n\tpublic void receive(Message<String> message){\n\t\tSystem.out.println(message);\n\t\tSystem.out.println(message.getPayload());\n\t}\n\n}\n```\n\n``@StreamListener``注解用于监听通道，由于我们在生产者发送的是一个\"Hello World\"字符串，因此在这里我们用``Message<String>``来接收它，**注意``Message``用的是``org.springframework.messaging.Message``**；\n\n4.与生产者一样，在启动类上添加``@EnableBinding(MyChannel.class)``。\n\n消费者至此也编写完毕，是不是很简单呢？现在让我们测试一下到底能不能发送和接收消息吧。\n\n## 2.3 调试发送\n\n首先启动消费者``sc-stream-consumer``微服务，如果你激活了``RabbitMQ``管理平台，那么此时就可以在上面看到``test``通道的相关信息了，包括``Exchange``和``Queue``：\n\n![image](http://airoland.github.io/data/article/20170608191258458/RabbitMQ-Management.png)\n\n接下来启动生产者``sc-stream-producer``微服务，调用``localhost:8080/send``，或者不启动服务直接用``JUnit``来调试。\n\n然后我们就可以看到消费者的控制台输出了一条消息：\n\n```\nGenericMessage [payload=Hello World, headers={amqp_receivedDeliveryMode=PERSISTENT, amqp_receivedRoutingKey=test, amqp_receivedExchange=test, amqp_deliveryTag=1, amqp_consumerQueue=test.anonymous.LygfgzNbRgyY4I57dzAnAw, amqp_redelivered=false, id=f26952a0-f134-3743-3e29-13c90335d6ed, amqp_consumerTag=amq.ctag-8cRY_wgqX38-ugJimY2RXA, contentType=text/plain, timestamp=1496909390677}]\n```\n\n以及通过``message.getPayload()``获取到的消息实体：\n\n```\nHello World\n```\n\n至此我们就完成了简单的消息发送与接收服务，是不是感觉很快就能起飞了呢？（笑）\n\n## 2.4 手动配置\n\n在开头我提到可以暂时不对``RabbitMQ``做配置，这是为了我们可以快速开发调试。但现实中我们不可能不去修改``RabbitMQ``的配置（哪怕只是改改密码，毕竟guest相当于裸奔），那么如何让SCS去匹配修改过的配置呢？\n\n单就YAML配置来说，有两种方式（使用``@Configuration``类做配置的朋友请自行对照）：\n\n1.直接配置``spring.rabbitmq``，比如我使用另外一个用户连接，并且配了virtual host：\n\n```\nspring:\n  rabbitmq:\n    username: airoland\n    password: 123456\n    virtual-host: /test\n```\n\n2.使用``spring.cloud.stream.binders``和``spring.cloud.stream.bindings``组合配置，同样是上面的情况：\n\n```\nspring:\n  cloud:\n    stream:\n      bindings:\n        test:\n          binder: rabbit\n      binders:\n        rabbit:\n          type: rabbit\n          environment:\n            spring:\n              rabbitmq:\n                username: airoland\n                password: 123456\n                virtual-host: /test\n```\n\n乍一看感觉好麻烦呀，而且``environment``下面的配置不就是上面``spring.rabbitmq``的配置吗？\n\n实际上这种写法是有它的好处的，首先我们注意到，``binders``里面可以配置不同环境的``binder``，而通过``bindings``我们可以把``channel``和``binder``绑定起来。\n\n假设我这个微服务现在要连两个``RabbitMQ``，那么我们就可以这样配置：\n\n```\nspring:\n  cloud:\n    stream:\n      bindings:\n        test1:\n          binder: rabbit1\n        test2:\n          binder: rabbit2\n      binders:\n        rabbit1:\n          type: rabbit\n          environment:\n            spring:\n              rabbitmq:\n                host: 192.168.1.1\n                port: 5672\n                username: airoland\n                password: 123456\n                virtual-host: /test1\n        rabbit2:\n          type: rabbit\n          environment:\n            spring:\n              rabbitmq:\n                host: 192.168.1.2\n                port: 5673\n                username: airoland\n                password: 456789\n                virtual-host: /test2\n```\n\n注：``spring.cloud.stream.bindings.<channelName>``里面有许多有用的配置，比如``destination``、``group``等等，后面我们还会使用到这个配置。\n\n# 3. 进阶\n\n## 3.1 传递对象\n\n上一节中我们发送的消息是一个字符串，那如果我想发送POJO怎么办呢？是直接发送和接收就可以了吗？下面我们可以试验一下：\n\n首先创建一个User POJO，然后修改生产者``sc-stream-producer``的``send()``方法：\n\n```\nUser user = new User();\nuser.setId(\"1\");\nuser.setName(\"airoland\");\ntry {\n    sender.output().send(MessageBuilder.withPayload(user).build());\n} catch (Exception e) {\n    e.printStackTrace();\n}\n```\n\n修改消费者``sc-stream-consumer``的``receive()``方法：\n\n```\n@StreamListener(MyChannel.INPUT)\npublic void receive(Message<User> message){\n    System.out.println(message);\n    System.out.println(message.getPayload());\n}\n```\n\n这样试验后我们可能得到两种结果：\n\n1. 如果你的User是分别在生产者和消费者中定义的，并且**包路径不同**，那么会报错反序列化失败。原因是SCS会默认将POJO转换成二进制发送，并且**携带包路径等信息**；\n\n2. 如果生产者和消费者使用的User是同一定义，或分别定义但包路径相同，那么就不会报错。 \n\n看起来略微有点不爽，那么有没有别的转换方式呢？\n\n不仅有，而且官方还提供了很多：\n\n![image](http://airoland.github.io/data/article/20170608191258458/spring-cloud-stream-conversions.png)\n\n下面我会举例用JSON字符串来传递POJO，其实只要在生产者``sc-stream-producer``中加上一条配置即可：\n\n```\nspring:\n  cloud:\n    stream:\n      bindings:\n        test:\n          content-type: application/json\n```\n\n此时消费者``sc-stream-consumer``接收的消息实体实际上是字符串了，我们可以用``Message<String>``来测试一下：\n\n```\n@StreamListener(MyChannel.INPUT)\npublic void receive(Message<String> message){\n    System.out.println(message);\n    System.out.println(message.getPayload());\n}\n```\n\n控制台会打印：\n\n```\nGenericMessage [payload={\"id\":\"1\",\"name\":\"airoland\"}, headers={amqp_receivedDeliveryMode=PERSISTENT, amqp_receivedRoutingKey=test, amqp_receivedExchange=test, amqp_deliveryTag=1, amqp_consumerQueue=test.anonymous.fCtAYLGGR8WV3-GFR7Apqw, amqp_redelivered=false, id=c0da5727-57a5-83d1-603b-8ee51491dac4, amqp_consumerTag=amq.ctag-3LC5QcQph-K08f_z4v0HXg, contentType=application/json;charset=UTF-8, timestamp=1496916137814}]\n{\"id\":\"1\",\"name\":\"airoland\"}\n```\n\n好了，既然接收的是JSON字符串了，那Spring怎么可能不提供自动反射呢XD，再次把消息实体换回User测试：\n\n```\n@StreamListener(MyChannel.INPUT)\npublic void receive(Message<User> message){\n    System.out.println(message);\n    System.out.println(message.getPayload());\n    System.out.println(content.getPayload().getName());\n}\n```\n\n控制台会打印：\n\n```\nGenericMessage [payload=sc.stream.consumer.model.User@533f86c6, headers={amqp_receivedDeliveryMode=PERSISTENT, amqp_receivedRoutingKey=test, amqp_receivedExchange=test, amqp_deliveryTag=1, amqp_consumerQueue=test.anonymous.0d3Rg1FJREWiYLvrwJ_6lQ, amqp_redelivered=false, id=235184ca-7e22-4a20-e559-3a00624bb28b, amqp_consumerTag=amq.ctag-9GakIl7L8iPN7a2wAsAS1w, contentType=application/json;charset=UTF-8, timestamp=1496916250919}]\nsc.stream.consumer.model.User@533f86c6\nairoland\n```\n\n## 3.2 负载均衡实例\n\n实际生产中，我们一般都会启动多个消费者实例来做负载均衡，既然是负载均衡，我们肯定希望**一条消息在一组负载均衡实例中只被其中一个消费者接收**。那么SCS是如何处理这种情况的呢？\n\n假设我们现在已经启动了生产者``sc-stream-producer``和消费者``sc-stream-consumer``实例各一个，然后再修改消费者的端口为8082，再启动一个消费者实例。\n\n随后发送消息测试，我们会发现两个消费者实例都接收到了消息：\n\nsc-stream-consumer:8081控制台打印：\n\n```\nGenericMessage [payload=Hello World, headers={amqp_receivedDeliveryMode=PERSISTENT, amqp_receivedRoutingKey=test, amqp_receivedExchange=test, amqp_deliveryTag=1, amqp_consumerQueue=test.anonymous.bKjOVoNmS2a8PFNvAvRN0g, amqp_redelivered=false, id=913591e3-74ce-b3b3-1df8-8ccf3403b863, amqp_consumerTag=amq.ctag-gtlAtMGg1_reM_c4v2799Q, contentType=application/json, timestamp=1496916450093}]\n```\n\nsc-stream-consumer:8082控制台打印：\n\n```\nGenericMessage [payload=Hello World, headers={amqp_receivedDeliveryMode=PERSISTENT, amqp_receivedRoutingKey=test, amqp_receivedExchange=test, amqp_deliveryTag=1, amqp_consumerQueue=test.anonymous.3xdkxUFdS5qoxpA7vdwxow, amqp_redelivered=false, id=25eb9e46-14ee-c160-8b71-1adb71641899, amqp_consumerTag=amq.ctag-i9ZySLJ3YLYxL2alLqKKFA, contentType=application/json, timestamp=1496916450106}]\n```\n\n这显然不是我们希望的，那么现在就来分析一下为什么会出现这种情况。\n\n关键点在``headers``中的``amqp_consumerQueue``这个属性上，我们看到8081和8082的``amqp_consumerQueue``前面都是``test.anonymous``，但后面却是不一样的。**这其实表示他们被分到了不同的匿名组**（即group），而同一条消息会被``test``中的**每个组**都接收到。\n\n这个也很好理解，我们把group比喻成现实中的公司各部门，现在我要发一个通知，我会发给所有的部门，但同一部门中只要有一个人收到了，我就认为这个部门收到了通知。\n\n所以只要把要负载均衡的实例分在同一个group下就好了，我们给消费者``sc-stream-consumer``添加如下配置：\n\n```\nspring:\n  cloud:\n    stream:\n      bindings:\n        test:\n          group: air  #设定组的名称\n```\n\n注：可以看出，如果不配置此项的话SCS就会把实例随机分到一个匿名组中。\n\n现在再次重启两个消费者实例，发送消息后会发现，这次只有8081接收到了消息：\n\n```\nGenericMessage [payload=Hello World, headers={amqp_receivedDeliveryMode=PERSISTENT, amqp_receivedRoutingKey=test, amqp_receivedExchange=test, amqp_deliveryTag=1, amqp_consumerQueue=test.air, amqp_redelivered=false, id=76eccd13-021a-132e-b171-4dc0f4716232, amqp_consumerTag=amq.ctag-c_pp9j2iNlPKfdFOZqfUWQ, contentType=application/json, timestamp=1496918019778}]\n```\n\n再次发送消息，会发现8082接收到了消息：\n\n```\nGenericMessage [payload=Hello World, headers={amqp_receivedDeliveryMode=PERSISTENT, amqp_receivedRoutingKey=test, amqp_receivedExchange=test, amqp_deliveryTag=1, amqp_consumerQueue=test.air, amqp_redelivered=false, id=f50d430d-ca59-480c-0f5d-3b2d1e94061f, amqp_consumerTag=amq.ctag-ebP2fkVc_cYwTNDt6-PAXw, contentType=application/json, timestamp=1496918059536}]\n```\n\n而且注意到两个实例的``amqp_consumerQueue``都变成了``test.air``。\n\n我建议大家在使用SCS时最好为消费者设置好``group``，否则即使是单实例消费者，它在每次启动时也都会被分配到不同的匿名组，其相应队列也会不断变化，这样一来生产者无法将消息送入固定队列中，造成的最大问题就是当消费者下线时，没有一个固定队列来缓存消息，好让消费者上线后直接获取。也就是说，**如果不分配组，那么当消费者下线时，生产者发送的消息将会消失**~~（在风中）~~。\n\n## 3.3 关于Publisher-Confirms\n\n根据Stack Overflow上[spring-cloud-stream-rabbitmq-publisher-confirm](https://stackoverflow.com/questions/43234942/spring-cloud-stream-rabbitmq-publisher-confirm)问题中Gary Russell的回答：\n\n![image](http://airoland.github.io/data/article/20170608191258458/spring-cloud-stream-rabbitmq-publisher-confirm.png)\n\n可以看到SCS并不支持``RabbitMQ``的``publisher-confirms``，他回答时SCS的版本是``Brooklyn.SR3``，而截止到本文发表SCS最新正式版本是``Chelsea.SR2``，我翻了一下依然不支持``publisher-confirms``，估计这事儿就此搁浅。\n\n当然了，他在回答中也说可以用事务来解决（虽然性能较低），关于如何启用事务，官方文档中提到了在``spring.cloud.stream.rabbit.bindings.<channelName>.producer``和``spring.cloud.stream.rabbit.bindings.<channelName>.consumer``中可以配置``transacted``来决定是否对通道启用事务，此属性默认为``false``。\n\n另外一种方法是直接使用``RabbitTemplate``或``Spring Integration Outbound Channel Adapter``来代替``binder``，这块与SCS已经关系不大，网上也有很多资料，本文就不再赘述了。\n\n# 4. 小结\n\n本文主要从入门的角度介绍了如何使用SCS，有兴趣深入研究的同学可以多看看官方文档和源码，SCS提供了一定便利性，但某些配置尚不支持，当然了看官方文档里面其实可配置的东西还是非常多的，所以大家可以根据自己的业务需求来选择是否使用。\n\n后期我可能会再针对SCS中的某些方面写点比较深入的文章（在懒癌不发作的前提下），本文就到此结束了，感谢大家的阅读！\n\n全文完。\n\n转载时请注明 **原作者 A.I.Roland (博客地址：https://airoland.github.io/)** ，并附上 **原文链接** ，谢谢！",
    "abstract": "Spring Cloud Stream（以下简称SCS）是一个用于构建消息驱动微服务的框架。简单来说，通过SCS我们可以快速地在微服务之间传递异步消息，这对于一些刚起步时需求简单的消息应用是很方便的。感谢Spring团队又喂了我们一个大块语法糖（笑）。尽管很方便，但必要的准备工作还是要做的。SCS本身并不提供消息服务器，因此我们还是要安装像RabbitMQ或Kafka这样的消息服务器，本文会使用RabbitMQ来做讲解...",
    "html": "<ul><li><a href=\"javascript:document.getElementById('1-').scrollIntoView()\">1. 概述</a></li>\n<li><a href=\"javascript:document.getElementById('2-').scrollIntoView()\">2. 入门</a>\n<ul><li><a href=\"javascript:document.getElementById('2-1-').scrollIntoView()\">2.1 生产者</a></li>\n<li><a href=\"javascript:document.getElementById('2-2-').scrollIntoView()\">2.2 消费者</a></li>\n<li><a href=\"javascript:document.getElementById('2-3-').scrollIntoView()\">2.3 调试发送</a></li>\n<li><a href=\"javascript:document.getElementById('2-4-').scrollIntoView()\">2.4 手动配置</a>\n</li>\n</ul>\n</li><li><a href=\"javascript:document.getElementById('3-').scrollIntoView()\">3. 进阶</a>\n<ul><li><a href=\"javascript:document.getElementById('3-1-').scrollIntoView()\">3.1 传递对象</a></li>\n<li><a href=\"javascript:document.getElementById('3-2-').scrollIntoView()\">3.2 负载均衡实例</a></li>\n<li><a href=\"javascript:document.getElementById('3-3-publisher-confirms').scrollIntoView()\">3.3 关于Publisher-Confirms</a>\n</li>\n</ul>\n</li><li><a href=\"javascript:document.getElementById('4-').scrollIntoView()\">4. 小结</a></li>\n</ul>\n\n<h1 id=\"1-\">1. 概述</h1>\n<p><code>Spring Cloud Stream</code>（以下简称SCS）是一个用于构建消息驱动微服务的框架。简单来说，通过SCS我们可以快速地在微服务之间传递异步消息，这对于一些刚起步时需求简单的消息应用是很方便的。<del>感谢Spring团队又喂了我们一个大块语法糖</del>（笑）。</p>\n<h1 id=\"2-\">2. 入门</h1>\n<p>尽管很方便，但必要的准备工作还是要做的。</p>\n<p>SCS本身并不提供消息服务器，因此我们还是要安装像<code>RabbitMQ</code>或<code>Kafka</code>这样的消息服务器，本文会使用<code>RabbitMQ</code>来做讲解，具体如何安装<code>Erlang</code>和<code>RabbitMQ</code>这里不再赘述。<strong>安装好以后可以暂时不对<code>RabbitMQ</code>做配置。</strong>但要记得运行<code>rabbitmq-plugins enable rabbitmq_management</code>来激活管理平台以方便后续使用（默认地址 localhost:15672，用户名密码都是guest）。</p>\n<p>随后在需要使用SCS的微服务中引入jar包：</p>\n<pre><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></pre><p>被<code>Spring Boot</code>的<code>AutoConfiguration</code>洗礼过的朋友应该知道，以<code>Spring</code>团队一贯的尿性，只要安装好环境引入jar包后，无需做任何多余配置微服务就应该可以跟<code>RabbitMQ</code>直接连上，而事实也的确如此。</p>\n<p>那我们就先不管<code>RabbitMQ</code>，直接开始编写微服务吧！</p>\n<h2 id=\"2-1-\">2.1 生产者</h2>\n<p>1.创建一个<code>sc-stream-producer</code>微服务，默认端口8080；</p>\n<p>2.创建一个接口作为通道，举例：</p>\n<pre><code><span class=\"hljs-meta\">@Component</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">MyChannel</span> </span>{\n\n    String OUTPUT = <span class=\"hljs-string\">\"test\"</span>;\n\n    <span class=\"hljs-meta\">@Output</span>(OUTPUT)\n    <span class=\"hljs-function\">MessageChannel <span class=\"hljs-title\">output</span><span class=\"hljs-params\">()</span></span>;\n\n}\n</code></pre><p><code>@Output</code>注解代表这是一个输出通道，而通道名就是我们定义的<code>test</code>，<strong>一个接口中可以定义多个输入和输出通道</strong>。</p>\n<p>实际上SCS本身提供了三个预定义接口通道，即<code>Source.class</code>单向输出通道，<code>Sink.class</code>单向输入通道，以及继承了它们两个的<code>Processor.class</code>，你可以在源码<code>org.springframework.cloud.stream.messaging</code>包中找到它们。但它们都只是简单示例，真正开发时我们肯定还是要自定义接口作为通道；</p>\n<p>3.创建用于发送消息的接口（或直接在启动类中编写）：</p>\n<pre><code><span class=\"hljs-meta\">@RestController</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SendController</span> </span>{\n\n    <span class=\"hljs-meta\">@Autowired</span>\n    <span class=\"hljs-keyword\">private</span> MyChannel sender;\n\n    <span class=\"hljs-meta\">@RequestMapping(<span class=\"hljs-meta-string\">\"/send\"</span>)</span>\n    <span class=\"hljs-keyword\">public</span> String send(){\n        <span class=\"hljs-keyword\">try</span> {\n            sender.output().send(MessageBuilder.withPayload(<span class=\"hljs-string\">\"Hello World\"</span>).build());\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"success\"</span>;\n        } <span class=\"hljs-keyword\">catch</span> (Exception e) {\n            e.printStackTrace();\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"fail\"</span>;\n        }\n    }\n\n}\n</code></pre><p>当然，你也可以使用<code>Spring Boot Test</code>直接测试：</p>\n<pre><code><span class=\"hljs-variable\">@RunWith</span>(SpringRunner.class)\n<span class=\"hljs-variable\">@SpringBootTest</span>\npublic class ScStreamProducerApplicationTests {\n\n    <span class=\"hljs-variable\">@Autowired</span>\n    private MyChannel sender;\n\n    <span class=\"hljs-variable\">@Test</span>\n    public void send() throws Exception {\n        <span class=\"hljs-selector-tag\">sender</span><span class=\"hljs-selector-class\">.output</span>()<span class=\"hljs-selector-class\">.send</span>(MessageBuilder.withPayload(<span class=\"hljs-string\">\"Hello World\"</span>).build());\n    }\n\n}\n</code></pre><p>注：<code>MessageBuilder</code>使用<code>org.springframework.integration.support.MessageBuilder</code>或<code>org.springframework.messaging.support.MessageBuilder</code>都可以，本身前者就是对后者的整合，Payload则是消息实体；</p>\n<p>4.在启动类上添加<code>@EnableBinding</code>注解：</p>\n<pre><code><span class=\"hljs-variable\">@SpringBootApplication</span>\n<span class=\"hljs-variable\">@EnableBinding</span>(MyChannel.class)\npublic class ScStreamProducerApplication {\n\n    <span class=\"hljs-selector-tag\">public</span> <span class=\"hljs-selector-tag\">static</span> <span class=\"hljs-selector-tag\">void</span> <span class=\"hljs-selector-tag\">main</span>(String[] args) {\n        <span class=\"hljs-selector-tag\">SpringApplication</span><span class=\"hljs-selector-class\">.run</span>(ScStreamProducerApplication.class, args);\n    }\n\n}\n</code></pre><p>需要注意的是，<code>@EnableBinding</code>注解是必须要加的（即使你只使用<code>JUnit</code>测试），<strong>但并不是必须添加在启动类上</strong>，其实你可以把它放在任何一个<code>Spring</code>能够扫描到的类。但为了方便查找，还是<strong>推荐放在启动类或者消息类上</strong>。</p>\n<p>生产者至此告一段落，接下来我们看一下消费者。</p>\n<h2 id=\"2-2-\">2.2 消费者</h2>\n<p>1.创建一个<code>sc-stream-consumer</code>微服务，为防止与生产者冲突，端口号设为8081；</p>\n<p>2.和生产者一样，创建一个接口作为通道，举例：</p>\n<pre><code><span class=\"hljs-meta\">@Component</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">MyChannel</span> </span>{\n\n    String INPUT = <span class=\"hljs-string\">\"test\"</span>;\n\n    <span class=\"hljs-meta\">@Input</span>(INPUT)\n    <span class=\"hljs-function\">SubscribableChannel <span class=\"hljs-title\">input</span><span class=\"hljs-params\">()</span></span>;\n\n}\n</code></pre><p><code>@Input</code>注解代表这是一个输入通道，<strong>通道名需要与生产者对应才能接收消息</strong>，因此我们也定义为<code>test</code>；</p>\n<p>3.创建用于接收消息的类（或直接在启动类中编写）：</p>\n<pre><code>@<span class=\"hljs-keyword\">Component</span>\npublic class Receiver {\n\n    @<span class=\"hljs-keyword\">StreamListener</span>(<span class=\"hljs-keyword\">MyChannel</span>.<span class=\"hljs-keyword\">INPUT</span>)\n    public void receive(Message&lt;String&gt; message){\n        <span class=\"hljs-selector-tag\">System</span><span class=\"hljs-selector-class\">.out</span><span class=\"hljs-selector-class\">.println</span>(<span class=\"hljs-selector-tag\">message</span>);\n        <span class=\"hljs-selector-tag\">System</span><span class=\"hljs-selector-class\">.out</span><span class=\"hljs-selector-class\">.println</span>(<span class=\"hljs-selector-tag\">message</span><span class=\"hljs-selector-class\">.getPayload</span>());\n    }\n\n}\n</code></pre><p><code>@StreamListener</code>注解用于监听通道，由于我们在生产者发送的是一个&quot;Hello World&quot;字符串，因此在这里我们用<code>Message&lt;String&gt;</code>来接收它，<strong>注意<code>Message</code>用的是<code>org.springframework.messaging.Message</code></strong>；</p>\n<p>4.与生产者一样，在启动类上添加<code>@EnableBinding(MyChannel.class)</code>。</p>\n<p>消费者至此也编写完毕，是不是很简单呢？现在让我们测试一下到底能不能发送和接收消息吧。</p>\n<h2 id=\"2-3-\">2.3 调试发送</h2>\n<p>首先启动消费者<code>sc-stream-consumer</code>微服务，如果你激活了<code>RabbitMQ</code>管理平台，那么此时就可以在上面看到<code>test</code>通道的相关信息了，包括<code>Exchange</code>和<code>Queue</code>：</p>\n<p><img src=\"http://airoland.github.io/data/article/20170608191258458/RabbitMQ-Management.png\" alt=\"image\"></p>\n<p>接下来启动生产者<code>sc-stream-producer</code>微服务，调用<code>localhost:8080/send</code>，或者不启动服务直接用<code>JUnit</code>来调试。</p>\n<p>然后我们就可以看到消费者的控制台输出了一条消息：</p>\n<pre><code>GenericMessage [<span class=\"hljs-attr\">payload=Hello</span> World, <span class=\"hljs-attr\">headers={amqp_receivedDeliveryMode=PERSISTENT,</span> <span class=\"hljs-attr\">amqp_receivedRoutingKey=test,</span> <span class=\"hljs-attr\">amqp_receivedExchange=test,</span> <span class=\"hljs-attr\">amqp_deliveryTag=1,</span> <span class=\"hljs-attr\">amqp_consumerQueue=test.anonymous.LygfgzNbRgyY4I57dzAnAw,</span> <span class=\"hljs-attr\">amqp_redelivered=false,</span> <span class=\"hljs-attr\">id=f26952a0-f134-3743-3e29-13c90335d6ed,</span> <span class=\"hljs-attr\">amqp_consumerTag=amq.ctag-8cRY_wgqX38-ugJimY2RXA,</span> <span class=\"hljs-attr\">contentType=text/plain,</span> <span class=\"hljs-attr\">timestamp=1496909390677}]</span>\n</code></pre><p>以及通过<code>message.getPayload()</code>获取到的消息实体：</p>\n<pre><code><span class=\"hljs-attribute\">Hello World</span>\n</code></pre><p>至此我们就完成了简单的消息发送与接收服务，是不是感觉很快就能起飞了呢？（笑）</p>\n<h2 id=\"2-4-\">2.4 手动配置</h2>\n<p>在开头我提到可以暂时不对<code>RabbitMQ</code>做配置，这是为了我们可以快速开发调试。但现实中我们不可能不去修改<code>RabbitMQ</code>的配置（哪怕只是改改密码，毕竟guest相当于裸奔），那么如何让SCS去匹配修改过的配置呢？</p>\n<p>单就YAML配置来说，有两种方式（使用<code>@Configuration</code>类做配置的朋友请自行对照）：</p>\n<p>1.直接配置<code>spring.rabbitmq</code>，比如我使用另外一个用户连接，并且配了virtual host：</p>\n<pre><code><span class=\"hljs-attribute\">spring</span>:\n  <span class=\"hljs-attribute\">rabbitmq</span>:\n    <span class=\"hljs-attribute\">username</span>: airoland\n    <span class=\"hljs-attribute\">password</span>: <span class=\"hljs-number\">123456</span>\n    <span class=\"hljs-attribute\">virtual-host</span>: /test\n</code></pre><p>2.使用<code>spring.cloud.stream.binders</code>和<code>spring.cloud.stream.bindings</code>组合配置，同样是上面的情况：</p>\n<pre><code><span class=\"hljs-attribute\">spring</span>:\n  <span class=\"hljs-attribute\">cloud</span>:\n    <span class=\"hljs-attribute\">stream</span>:\n      <span class=\"hljs-attribute\">bindings</span>:\n        <span class=\"hljs-attribute\">test</span>:\n          <span class=\"hljs-attribute\">binder</span>: rabbit\n      <span class=\"hljs-attribute\">binders</span>:\n        <span class=\"hljs-attribute\">rabbit</span>:\n          <span class=\"hljs-attribute\">type</span>: rabbit\n          <span class=\"hljs-attribute\">environment</span>:\n            <span class=\"hljs-attribute\">spring</span>:\n              <span class=\"hljs-attribute\">rabbitmq</span>:\n                <span class=\"hljs-attribute\">username</span>: airoland\n                <span class=\"hljs-attribute\">password</span>: <span class=\"hljs-number\">123456</span>\n                <span class=\"hljs-attribute\">virtual-host</span>: /test\n</code></pre><p>乍一看感觉好麻烦呀，而且<code>environment</code>下面的配置不就是上面<code>spring.rabbitmq</code>的配置吗？</p>\n<p>实际上这种写法是有它的好处的，首先我们注意到，<code>binders</code>里面可以配置不同环境的<code>binder</code>，而通过<code>bindings</code>我们可以把<code>channel</code>和<code>binder</code>绑定起来。</p>\n<p>假设我这个微服务现在要连两个<code>RabbitMQ</code>，那么我们就可以这样配置：</p>\n<pre><code><span class=\"hljs-attribute\">spring</span>:\n  <span class=\"hljs-attribute\">cloud</span>:\n    <span class=\"hljs-attribute\">stream</span>:\n      <span class=\"hljs-attribute\">bindings</span>:\n        <span class=\"hljs-attribute\">test1</span>:\n          <span class=\"hljs-attribute\">binder</span>: rabbit1\n        <span class=\"hljs-attribute\">test2</span>:\n          <span class=\"hljs-attribute\">binder</span>: rabbit2\n      <span class=\"hljs-attribute\">binders</span>:\n        <span class=\"hljs-attribute\">rabbit1</span>:\n          <span class=\"hljs-attribute\">type</span>: rabbit\n          <span class=\"hljs-attribute\">environment</span>:\n            <span class=\"hljs-attribute\">spring</span>:\n              <span class=\"hljs-attribute\">rabbitmq</span>:\n                <span class=\"hljs-attribute\">host</span>: <span class=\"hljs-number\">192.168</span>.<span class=\"hljs-number\">1.1</span>\n                <span class=\"hljs-attribute\">port</span>: <span class=\"hljs-number\">5672</span>\n                <span class=\"hljs-attribute\">username</span>: airoland\n                <span class=\"hljs-attribute\">password</span>: <span class=\"hljs-number\">123456</span>\n                <span class=\"hljs-attribute\">virtual-host</span>: /test1\n        <span class=\"hljs-attribute\">rabbit2</span>:\n          <span class=\"hljs-attribute\">type</span>: rabbit\n          <span class=\"hljs-attribute\">environment</span>:\n            <span class=\"hljs-attribute\">spring</span>:\n              <span class=\"hljs-attribute\">rabbitmq</span>:\n                <span class=\"hljs-attribute\">host</span>: <span class=\"hljs-number\">192.168</span>.<span class=\"hljs-number\">1.2</span>\n                <span class=\"hljs-attribute\">port</span>: <span class=\"hljs-number\">5673</span>\n                <span class=\"hljs-attribute\">username</span>: airoland\n                <span class=\"hljs-attribute\">password</span>: <span class=\"hljs-number\">456789</span>\n                <span class=\"hljs-attribute\">virtual-host</span>: /test2\n</code></pre><p>注：<code>spring.cloud.stream.bindings.&lt;channelName&gt;</code>里面有许多有用的配置，比如<code>destination</code>、<code>group</code>等等，后面我们还会使用到这个配置。</p>\n<h1 id=\"3-\">3. 进阶</h1>\n<h2 id=\"3-1-\">3.1 传递对象</h2>\n<p>上一节中我们发送的消息是一个字符串，那如果我想发送POJO怎么办呢？是直接发送和接收就可以了吗？下面我们可以试验一下：</p>\n<p>首先创建一个User POJO，然后修改生产者<code>sc-stream-producer</code>的<code>send()</code>方法：</p>\n<pre><code><span class=\"hljs-type\">User</span> user = <span class=\"hljs-function\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title\">User</span>();\n<span class=\"hljs-title\">user</span>.<span class=\"hljs-title\">setId</span>(\"<span class=\"hljs-number\">1</span>\");\n<span class=\"hljs-title\">user</span>.<span class=\"hljs-title\">setName</span>(\"airoland\");\n<span class=\"hljs-title\">try</span> {\n    <span class=\"hljs-title\">sender</span>.<span class=\"hljs-title\">output</span>().<span class=\"hljs-title\">send</span>(<span class=\"hljs-type\">MessageBuilder</span>.withPayload(user).<span class=\"hljs-title\">build</span>());\n} <span class=\"hljs-title\">catch</span> (<span class=\"hljs-type\">Exception</span> e) {\n    <span class=\"hljs-title\">e</span>.<span class=\"hljs-title\">printStackTrace</span>();\n}</span>\n</code></pre><p>修改消费者<code>sc-stream-consumer</code>的<code>receive()</code>方法：</p>\n<pre><code>@<span class=\"hljs-keyword\">StreamListener</span>(<span class=\"hljs-keyword\">MyChannel</span>.<span class=\"hljs-keyword\">INPUT</span>)\npublic void receive(Message&lt;User&gt; message){\n    <span class=\"hljs-selector-tag\">System</span><span class=\"hljs-selector-class\">.out</span><span class=\"hljs-selector-class\">.println</span>(<span class=\"hljs-selector-tag\">message</span>);\n    <span class=\"hljs-selector-tag\">System</span><span class=\"hljs-selector-class\">.out</span><span class=\"hljs-selector-class\">.println</span>(<span class=\"hljs-selector-tag\">message</span><span class=\"hljs-selector-class\">.getPayload</span>());\n}\n</code></pre><p>这样试验后我们可能得到两种结果：</p>\n<ol>\n<li><p>如果你的User是分别在生产者和消费者中定义的，并且<strong>包路径不同</strong>，那么会报错反序列化失败。原因是SCS会默认将POJO转换成二进制发送，并且<strong>携带包路径等信息</strong>；</p>\n</li>\n<li><p>如果生产者和消费者使用的User是同一定义，或分别定义但包路径相同，那么就不会报错。 </p>\n</li>\n</ol>\n<p>看起来略微有点不爽，那么有没有别的转换方式呢？</p>\n<p>不仅有，而且官方还提供了很多：</p>\n<p><img src=\"http://airoland.github.io/data/article/20170608191258458/spring-cloud-stream-conversions.png\" alt=\"image\"></p>\n<p>下面我会举例用JSON字符串来传递POJO，其实只要在生产者<code>sc-stream-producer</code>中加上一条配置即可：</p>\n<pre><code><span class=\"hljs-attribute\">spring</span>:\n  <span class=\"hljs-attribute\">cloud</span>:\n    <span class=\"hljs-attribute\">stream</span>:\n      <span class=\"hljs-attribute\">bindings</span>:\n        <span class=\"hljs-attribute\">test</span>:\n          <span class=\"hljs-attribute\">content-type</span>: application/json\n</code></pre><p>此时消费者<code>sc-stream-consumer</code>接收的消息实体实际上是字符串了，我们可以用<code>Message&lt;String&gt;</code>来测试一下：</p>\n<pre><code>@<span class=\"hljs-keyword\">StreamListener</span>(<span class=\"hljs-keyword\">MyChannel</span>.<span class=\"hljs-keyword\">INPUT</span>)\npublic void receive(Message&lt;String&gt; message){\n    <span class=\"hljs-selector-tag\">System</span><span class=\"hljs-selector-class\">.out</span><span class=\"hljs-selector-class\">.println</span>(<span class=\"hljs-selector-tag\">message</span>);\n    <span class=\"hljs-selector-tag\">System</span><span class=\"hljs-selector-class\">.out</span><span class=\"hljs-selector-class\">.println</span>(<span class=\"hljs-selector-tag\">message</span><span class=\"hljs-selector-class\">.getPayload</span>());\n}\n</code></pre><p>控制台会打印：</p>\n<pre><code>GenericMessage [<span class=\"hljs-attr\">payload={\"id\":\"1\",\"name\":\"airoland\"},</span> <span class=\"hljs-attr\">headers={amqp_receivedDeliveryMode=PERSISTENT,</span> <span class=\"hljs-attr\">amqp_receivedRoutingKey=test,</span> <span class=\"hljs-attr\">amqp_receivedExchange=test,</span> <span class=\"hljs-attr\">amqp_deliveryTag=1,</span> <span class=\"hljs-attr\">amqp_consumerQueue=test.anonymous.fCtAYLGGR8WV3-GFR7Apqw,</span> <span class=\"hljs-attr\">amqp_redelivered=false,</span> <span class=\"hljs-attr\">id=c0da5727-57a5-83d1-603b-8ee51491dac4,</span> <span class=\"hljs-attr\">amqp_consumerTag=amq.ctag-3LC5QcQph-K08f_z4v0HXg,</span> <span class=\"hljs-attr\">contentType=application/json;charset=UTF-8,</span> <span class=\"hljs-attr\">timestamp=1496916137814}]</span>\n{<span class=\"hljs-string\">\"id\"</span>:<span class=\"hljs-string\">\"1\"</span>,<span class=\"hljs-string\">\"name\"</span>:<span class=\"hljs-string\">\"airoland\"</span>}\n</code></pre><p>好了，既然接收的是JSON字符串了，那Spring怎么可能不提供自动反射呢XD，再次把消息实体换回User测试：</p>\n<pre><code>@<span class=\"hljs-keyword\">StreamListener</span>(<span class=\"hljs-keyword\">MyChannel</span>.<span class=\"hljs-keyword\">INPUT</span>)\npublic void receive(Message&lt;User&gt; message){\n    <span class=\"hljs-selector-tag\">System</span><span class=\"hljs-selector-class\">.out</span><span class=\"hljs-selector-class\">.println</span>(<span class=\"hljs-selector-tag\">message</span>);\n    <span class=\"hljs-selector-tag\">System</span><span class=\"hljs-selector-class\">.out</span><span class=\"hljs-selector-class\">.println</span>(<span class=\"hljs-selector-tag\">message</span><span class=\"hljs-selector-class\">.getPayload</span>());\n    <span class=\"hljs-selector-tag\">System</span><span class=\"hljs-selector-class\">.out</span><span class=\"hljs-selector-class\">.println</span>(<span class=\"hljs-selector-tag\">content</span><span class=\"hljs-selector-class\">.getPayload</span>()<span class=\"hljs-selector-class\">.getName</span>());\n}\n</code></pre><p>控制台会打印：</p>\n<pre><code>GenericMessage [payload=sc.stream.consumer.model.User@<span class=\"hljs-number\">533</span>f86c6, headers={amqp_receivedDeliveryMode=PERSISTENT, amqp_receivedRoutingKey=test, amqp_receivedExchange=test, amqp_deliveryTag=<span class=\"hljs-number\">1</span>, amqp_consumerQueue=test.anonymous<span class=\"hljs-number\">.0</span>d3Rg1FJREWiYLvrwJ_6lQ, amqp_redelivered=false, id=<span class=\"hljs-number\">235184</span>ca<span class=\"hljs-number\">-7e22</span><span class=\"hljs-number\">-4</span>a20-e559<span class=\"hljs-number\">-3</span>a00624bb28b, amqp_consumerTag=amq.ctag<span class=\"hljs-number\">-9</span>GakIl7L8iPN7a2wAsAS1w, contentType=application/json;charset=UTF<span class=\"hljs-number\">-8</span>, timestamp=<span class=\"hljs-number\">1496916250919</span>}]\nsc.stream.consumer.model.User@<span class=\"hljs-number\">533</span>f86c6\nairoland\n</code></pre><h2 id=\"3-2-\">3.2 负载均衡实例</h2>\n<p>实际生产中，我们一般都会启动多个消费者实例来做负载均衡，既然是负载均衡，我们肯定希望<strong>一条消息在一组负载均衡实例中只被其中一个消费者接收</strong>。那么SCS是如何处理这种情况的呢？</p>\n<p>假设我们现在已经启动了生产者<code>sc-stream-producer</code>和消费者<code>sc-stream-consumer</code>实例各一个，然后再修改消费者的端口为8082，再启动一个消费者实例。</p>\n<p>随后发送消息测试，我们会发现两个消费者实例都接收到了消息：</p>\n<p>sc-stream-consumer:8081控制台打印：</p>\n<pre><code>GenericMessage [<span class=\"hljs-attr\">payload=Hello</span> World, <span class=\"hljs-attr\">headers={amqp_receivedDeliveryMode=PERSISTENT,</span> <span class=\"hljs-attr\">amqp_receivedRoutingKey=test,</span> <span class=\"hljs-attr\">amqp_receivedExchange=test,</span> <span class=\"hljs-attr\">amqp_deliveryTag=1,</span> <span class=\"hljs-attr\">amqp_consumerQueue=test.anonymous.bKjOVoNmS2a8PFNvAvRN0g,</span> <span class=\"hljs-attr\">amqp_redelivered=false,</span> <span class=\"hljs-attr\">id=913591e3-74ce-b3b3-1df8-8ccf3403b863,</span> <span class=\"hljs-attr\">amqp_consumerTag=amq.ctag-gtlAtMGg1_reM_c4v2799Q,</span> <span class=\"hljs-attr\">contentType=application/json,</span> <span class=\"hljs-attr\">timestamp=1496916450093}]</span>\n</code></pre><p>sc-stream-consumer:8082控制台打印：</p>\n<pre><code>GenericMessage [payload=Hello World, headers={amqp_receivedDeliveryMode=PERSISTENT, amqp_receivedRoutingKey=test, amqp_receivedExchange=test, amqp_deliveryTag=<span class=\"hljs-number\">1</span>, amqp_consumerQueue=test.anonymous.3xdkxUFdS5qoxpA7vdwxow, amqp_redelivered=<span class=\"hljs-literal\">false</span>, id=25eb9e46-14ee-c160-<span class=\"hljs-number\">8b71</span>-1adb71641899, amqp_consumerTag=amq.ctag-i9ZySLJ3YLYxL2alLqKKFA, contentType=application/json, timestamp=<span class=\"hljs-number\">1496916450106</span>}]\n</code></pre><p>这显然不是我们希望的，那么现在就来分析一下为什么会出现这种情况。</p>\n<p>关键点在<code>headers</code>中的<code>amqp_consumerQueue</code>这个属性上，我们看到8081和8082的<code>amqp_consumerQueue</code>前面都是<code>test.anonymous</code>，但后面却是不一样的。<strong>这其实表示他们被分到了不同的匿名组</strong>（即group），而同一条消息会被<code>test</code>中的<strong>每个组</strong>都接收到。</p>\n<p>这个也很好理解，我们把group比喻成现实中的公司各部门，现在我要发一个通知，我会发给所有的部门，但同一部门中只要有一个人收到了，我就认为这个部门收到了通知。</p>\n<p>所以只要把要负载均衡的实例分在同一个group下就好了，我们给消费者<code>sc-stream-consumer</code>添加如下配置：</p>\n<pre><code><span class=\"hljs-symbol\">spring:</span>\n<span class=\"hljs-symbol\">  cloud:</span>\n<span class=\"hljs-symbol\">    stream:</span>\n<span class=\"hljs-symbol\">      bindings:</span>\n<span class=\"hljs-symbol\">        test:</span>\n<span class=\"hljs-symbol\">          group:</span> air  <span class=\"hljs-meta\">#设定组的名称</span>\n</code></pre><p>注：可以看出，如果不配置此项的话SCS就会把实例随机分到一个匿名组中。</p>\n<p>现在再次重启两个消费者实例，发送消息后会发现，这次只有8081接收到了消息：</p>\n<pre><code>GenericMessage [<span class=\"hljs-attr\">payload=Hello</span> World, <span class=\"hljs-attr\">headers={amqp_receivedDeliveryMode=PERSISTENT,</span> <span class=\"hljs-attr\">amqp_receivedRoutingKey=test,</span> <span class=\"hljs-attr\">amqp_receivedExchange=test,</span> <span class=\"hljs-attr\">amqp_deliveryTag=1,</span> <span class=\"hljs-attr\">amqp_consumerQueue=test.air,</span> <span class=\"hljs-attr\">amqp_redelivered=false,</span> <span class=\"hljs-attr\">id=76eccd13-021a-132e-b171-4dc0f4716232,</span> <span class=\"hljs-attr\">amqp_consumerTag=amq.ctag-c_pp9j2iNlPKfdFOZqfUWQ,</span> <span class=\"hljs-attr\">contentType=application/json,</span> <span class=\"hljs-attr\">timestamp=1496918019778}]</span>\n</code></pre><p>再次发送消息，会发现8082接收到了消息：</p>\n<pre><code>GenericMessage [<span class=\"hljs-attr\">payload=Hello</span> World, <span class=\"hljs-attr\">headers={amqp_receivedDeliveryMode=PERSISTENT,</span> <span class=\"hljs-attr\">amqp_receivedRoutingKey=test,</span> <span class=\"hljs-attr\">amqp_receivedExchange=test,</span> <span class=\"hljs-attr\">amqp_deliveryTag=1,</span> <span class=\"hljs-attr\">amqp_consumerQueue=test.air,</span> <span class=\"hljs-attr\">amqp_redelivered=false,</span> <span class=\"hljs-attr\">id=f50d430d-ca59-480c-0f5d-3b2d1e94061f,</span> <span class=\"hljs-attr\">amqp_consumerTag=amq.ctag-ebP2fkVc_cYwTNDt6-PAXw,</span> <span class=\"hljs-attr\">contentType=application/json,</span> <span class=\"hljs-attr\">timestamp=1496918059536}]</span>\n</code></pre><p>而且注意到两个实例的<code>amqp_consumerQueue</code>都变成了<code>test.air</code>。</p>\n<p>我建议大家在使用SCS时最好为消费者设置好<code>group</code>，否则即使是单实例消费者，它在每次启动时也都会被分配到不同的匿名组，其相应队列也会不断变化，这样一来生产者无法将消息送入固定队列中，造成的最大问题就是当消费者下线时，没有一个固定队列来缓存消息，好让消费者上线后直接获取。也就是说，<strong>如果不分配组，那么当消费者下线时，生产者发送的消息将会消失</strong><del>（在风中）</del>。</p>\n<h2 id=\"3-3-publisher-confirms\">3.3 关于Publisher-Confirms</h2>\n<p>根据Stack Overflow上<a href=\"https://stackoverflow.com/questions/43234942/spring-cloud-stream-rabbitmq-publisher-confirm\">spring-cloud-stream-rabbitmq-publisher-confirm</a>问题中Gary Russell的回答：</p>\n<p><img src=\"http://airoland.github.io/data/article/20170608191258458/spring-cloud-stream-rabbitmq-publisher-confirm.png\" alt=\"image\"></p>\n<p>可以看到SCS并不支持<code>RabbitMQ</code>的<code>publisher-confirms</code>，他回答时SCS的版本是<code>Brooklyn.SR3</code>，而截止到本文发表SCS最新正式版本是<code>Chelsea.SR2</code>，我翻了一下依然不支持<code>publisher-confirms</code>，估计这事儿就此搁浅。</p>\n<p>当然了，他在回答中也说可以用事务来解决（虽然性能较低），关于如何启用事务，官方文档中提到了在<code>spring.cloud.stream.rabbit.bindings.&lt;channelName&gt;.producer</code>和<code>spring.cloud.stream.rabbit.bindings.&lt;channelName&gt;.consumer</code>中可以配置<code>transacted</code>来决定是否对通道启用事务，此属性默认为<code>false</code>。</p>\n<p>另外一种方法是直接使用<code>RabbitTemplate</code>或<code>Spring Integration Outbound Channel Adapter</code>来代替<code>binder</code>，这块与SCS已经关系不大，网上也有很多资料，本文就不再赘述了。</p>\n<h1 id=\"4-\">4. 小结</h1>\n<p>本文主要从入门的角度介绍了如何使用SCS，有兴趣深入研究的同学可以多看看官方文档和源码，SCS提供了一定便利性，但某些配置尚不支持，当然了看官方文档里面其实可配置的东西还是非常多的，所以大家可以根据自己的业务需求来选择是否使用。</p>\n<p>后期我可能会再针对SCS中的某些方面写点比较深入的文章（在懒癌不发作的前提下），本文就到此结束了，感谢大家的阅读！</p>\n<p>全文完。</p>\n<p>转载时请注明 <strong>原作者 A.I.Roland (博客地址：<a href=\"https://airoland.github.io/\">https://airoland.github.io/</a>)</strong> ，并附上 <strong>原文链接</strong> ，谢谢！</p>\n"
}